       section   code
; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space

StackPointerVal     equ $08040000      when using sram
;StackPointerVal     equ $0C000000      when using dram

; define RamVectorTable as $0803000 if your system uses SRAM for main memory
; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)

RamVectorTable      equ $08030000      when using sram
;RamVectorTable      equ $0B000000      when using dram



; CSTART.ASM  -  C startup-code for Debug Monitor
                align

                org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0

InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
InitialPC       dc.l start             ;address of 1st instruction of program after a reset
BusError        dc.l E_BErro           ;bus error - stop program
AddressError    dc.l E_AErro           ;address error - stop program
IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
Check           dc.l E_Check           ;Check instruction - stop program
TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
Privilege       dc.l E_Priv            ;privilige violation - stop program
Trace           dc.l E_Trace           ;stop on trace
Line1010emul    dc.l E_1010            ;1010 instructions stop
Line1111emul    dc.l E_1111            ;1111 instructions stop
Unassigned1     dc.l E_Unnas1           ;unassigned vector
Unassigned2     dc.l E_Unnas2           ;unassigned vector
Unassigned3     dc.l E_Unnas3           ;unassigned vector
Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
Unassigned4     dc.l E_Unnas4           ;unassigned vector
Unassigned5     dc.l E_Unnas5           ;unassigned vector
Unassigned6     dc.l E_Unnas6           ;unassigned vector
Unassigned7     dc.l E_Unnas7           ;unassigned vector
Unassigned8     dc.l E_Unnas8           ;unassigned vector
Unassigned9     dc.l E_Unnas9           ;unassigned vector
Unassigned10    dc.l E_Unnas10           ;unassigned vector
Unassigned11    dc.l E_Unnas11           ;unassigned vector
SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
*
*
Level1IRQ       dc.l Level1RamISR
Level2IRQ       dc.l Level2RamISR
Level3IRQ       dc.l Level3RamISR
Level4IRQ       dc.l Level4RamISR
Level5IRQ       dc.l Level5RamISR
Level6IRQ       dc.l Level6RamISR
Level7IRQ       dc.l Level7RamISR
*
*
Trap0           dc.l Trap0RamISR        ; User installed trap handler
Trap1           dc.l Trap1RamISR        ; User installed trap handler
Trap2           dc.l Trap2RamISR        ; User installed trap handler
Trap3           dc.l Trap3RamISR        ; User installed trap handler
Trap4           dc.l Trap4RamISR        ; User installed trap handler
Trap5           dc.l Trap5RamISR        ; User installed trap handler
Trap6           dc.l Trap6RamISR        ; User installed trap handler
Trap7           dc.l Trap7RamISR        ; User installed trap handler
Trap8           dc.l Trap8RamISR        ; User installed trap handler
Trap9           dc.l Trap9RamISR        ; User installed trap handler
Trap10          dc.l Trap10RamISR       ; User installed trap handler
Trap11          dc.l Trap11RamISR       ; User installed trap handler
Trap12          dc.l Trap12RamISR       ; User installed trap handler
Trap13          dc.l Trap13RamISR       ; User installed trap handler
Trap14          dc.l Trap14RamISR       ; User installed trap handler
Trap15          dc.l Trap15RamISR       ; User installed trap handler

*
* Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
*

                org       $00000400

start:          move.w     #$2700,SR             ;set interrupts to disable until later

*************************************************************************************
** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
** important, it just creates read and write bus cycles to specific addresses which
** help with debugging hardware in Quartus simulations
**************************************************************************************

                ; some important initialisation do not modify
                move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
                move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
                move.l    #heap,__heap    ; pointer to free memory
                move.w    #$2000,SR       ; enable interrupts

mainloop        jsr       _main
                bra       mainloop

*********************************************************************************************************
* Code to call Ram Based Interrupt handler and other exeception handler code
*********************************************************************************************************
Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL1IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL2IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL3IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL4IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

* Trace trap Handler

Level5RamISR
*
**         Copy 68000 registers from debug monitor Variables,
*
*
                move.l    #1,_Trace              switch on Trace Mode
                move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
                move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
                move.l    (sp)+,_PC              get at the users program counter and copy
*
                move.l    SP,_SSP                copy system stack pointer to debug monitor variable
                move.l    d0,_d0
                move.l    d1,_d1
                move.l    d2,_d2
                move.l    d3,_d3
                move.l    d4,_d4
                move.l    d5,_d5
                move.l    d6,_d6
                move.l    d7,_d7
*
                move.l    a0,_a0
                move.l    a1,_a1
                move.l    a2,_a2
                move.l    a3,_a3
                move.l    a4,_a4
                move.l    a5,_a5
                move.l    a6,_a6
                move.l    usp,a0
                move.l    a0,_USP
*
                move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
                jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address

** After trace, reload 68000 registers with new values before continuing

                move.l   _d0,d0
                move.l   _d1,d1
                move.l   _d2,d2
                move.l   _d3,d3
                move.l   _d4,d4
                move.l   _d5,d5
                move.l   _d6,d6
                move.l   _d7,d7

                move.l   _USP,a0
                move.l   a0,USP                     load user stack pointer
                move.l   _a0,a0
                move.l   _a1,a1
                move.l   _a2,a2
                move.l   _a3,a3
                move.l   _a4,a4
                move.l   _a5,a5
                move.l   _a6,a6

                move.l   _SSP,sp
                move.l   _PC,-(sp)
                move.w   _SR,-(sp)
                move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
                rte

* address trap handler

Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL6IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL7IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte


********************************************************************************************************
* Ram based Trap handler and other exeception handler code
*********************************************************************************************************

Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap0,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap1,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap2,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap3,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap4,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap5,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap6,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap7,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap8,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap9,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap10,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap11,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap12,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap13,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap14RamISR    ;Break Point Handler
*
**         Copy 68000 registers from debug monitor Variables
*
                move.l    #1,_Trace      switch on Trace Mode
                move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
                move.l    (sp)+,_PC      get at the users program counter and copy
*
                move.l    d0,_d0
                move.l    d1,_d1
                move.l    d2,_d2
                move.l    d3,_d3
                move.l    d4,_d4
                move.l    d5,_d5
                move.l    d6,_d6
                move.l    d7,_d7
*
                move.l    a0,_a0
                move.l    a1,_a1
                move.l    a2,_a2
                move.l    a3,_a3
                move.l    a4,_a4
                move.l    a5,_a5
                move.l    a6,_a6
                move.l    USP,a0
                move.l    a0,_USP
*
                move.l    VTrap14,a0             get ram based address into a0
                jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address

** After breakpoint reload 68000 registers with new values before continuing

*                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
                move.l   _d0,d0
                move.l   _d1,d1
                move.l   _d2,d2
                move.l   _d3,d3
                move.l   _d4,d4
                move.l   _d5,d5
                move.l   _d6,d6
                move.l   _d7,d7

                move.l   _USP,a0
                move.l   a0,USP        load user stack pointer A7
                move.l   _a0,a0
                move.l   _a1,a1
                move.l   _a2,a2
                move.l   _a3,a3
                move.l   _a4,a4
                move.l   _a5,a5
                move.l   _a6,a6

                move.l   _PC,-(sp)
                move.w   _SR,-(sp)
                rte

Trap15RamISR    jmp     _CallDebugMonitor
*                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
*                move.l    VTrap15,a0                get ram based address into a0
*                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
*                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
*                rte

*********************************************************************************************************
*Default exception handler for everything without a specific handler
*********************************************************************************************************

*
**              Jump here for each unhandled exception
**              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
*

E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VBusError,a0            get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VAddressError,a0        get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VIllegalInstr,a0        get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VDividebyZero,a0        get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VCheck,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrapV,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VPrivilege,a0           get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrace,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VLine1010emul,a0        get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VLine1111emul,a0        get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_Unnas1
E_Unnas2
E_Unnas3
E_UnitI
E_Unnas4
E_Unnas5
E_Unnas6
E_Unnas7
E_Unnas8
E_Unnas9
E_Unnas10
E_Unnas11
E_Spuri
_stop            bra _stop                         stop
***************************************************************************************************
* Go() function in debug monitor
***************************************************************************************************
_go
                move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
                move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
                move.w   _SR,-(sp)      copy debug monitor status reg to the stack

                move.b   $00000078,d0  remove any spurious address exception arising after power on
                move.l   _d0,d0
                move.l   _d1,d1
                move.l   _d2,d2
                move.l   _d3,d3
                move.l   _d4,d4
                move.l   _d5,d5
                move.l   _d6,d6
                move.l   _d7,d7

                move.l   _USP,a0
                move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
                move.l   _a0,a0
                move.l   _a1,a1
                move.l   _a2,a2
                move.l   _a3,a3
                move.l   _a4,a4
                move.l   _a5,a5
                move.l   _a6,a6
                rte                    load the status reg and PC from the stack and commence running
                                       *used to be rte but this didn't load the status byte

; C:\USERS\10054\ONEDRIVE\CPEN 412 FINAL PROJECT\FINAL_PROJECT_2023_SEM2_STUDENT_TEMPLATE\FINAL_PROJECT_2023_SEM2_STUDENT_TEMPLATE\PROGRAMS\DEBUGMONITORCODE\M68KDEBUG (NO DISASSEMBLER).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
; #include "DebugMonitor.h"
; #include "say_phoneme.h"
; // use 08030000 for a system running from sram or 0B000000 for system running from dram
; #define StartOfExceptionVectorTable 0x08030000
; //#define StartOfExceptionVectorTable 0x0B000000
; // use 0C000000 for dram or hex 08040000 for sram
; #define TopOfStack 0x08040000
; //#define TopOfStack 0x0C000000
; #define voice *(char*)(0xFF00FFFE)
; #define VGA_ADDRESS 0xFFFF0000 
; #define octlAddress1 *(char *)(0xFF030001)
; #define octlAddress *(char *)(0xFF030000)
; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
; unsigned int i, x, y, z, PortA_Count;
; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
; unsigned int d0,d1,d2,d3,d4,d5,d6,d7 ;
; unsigned int a0,a1,a2,a3,a4,a5,a6 ;
; unsigned int PC, SSP, USP ;
; unsigned short int SR;
; // Breakpoint variables
; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
; unsigned short int BreakPointInstruction[8] ;           // to hold the instruction opcode at the breakpoint
; unsigned int BreakPointSetOrCleared[8] ;
; unsigned int InstructionSize ;
; // watchpoint variables
; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
; unsigned int WatchPointSetOrCleared[8] ;
; char WatchPointString[8][100] ;
; char    TempString[100] ;
; void Wait1ms(void)
; {
_Wait1ms:
       move.l    D2,-(A7)
; int i;
; for (i = 0; i < 1000; i++)
       clr.l     D2
Wait1ms_1:
       cmp.l     #1000,D2
       bge.s     Wait1ms_3
       addq.l    #1,D2
       bra       Wait1ms_1
Wait1ms_3:
       move.l    (A7)+,D2
       rts
; ;
; }
; void Wait3ms(void)
; {
_Wait3ms:
       move.l    D2,-(A7)
; int i;
; for (i = 0; i < 3; i++)
       clr.l     D2
Wait3ms_1:
       cmp.l     #3,D2
       bge.s     Wait3ms_3
; Wait1ms();
       jsr       _Wait1ms
       addq.l    #1,D2
       bra       Wait3ms_1
Wait3ms_3:
       move.l    (A7)+,D2
       rts
; }
; void Wait250ms(void)
; {
_Wait250ms:
       move.l    D2,-(A7)
; int i;
; for (i = 0; i < 250; i++)
       clr.l     D2
Wait250ms_1:
       cmp.l     #250,D2
       bge.s     Wait250ms_3
; Wait1ms();
       jsr       _Wait1ms
       addq.l    #1,D2
       bra       Wait250ms_1
Wait250ms_3:
       move.l    (A7)+,D2
       rts
; }
; void Wait500ms(void)
; {
_Wait500ms:
       move.l    D2,-(A7)
; int i;
; for (i = 0; i < 500; i++)
       clr.l     D2
Wait500ms_1:
       cmp.l     #500,D2
       bge.s     Wait500ms_3
; Wait1ms();
       jsr       _Wait1ms
       addq.l    #1,D2
       bra       Wait500ms_1
Wait500ms_3:
       move.l    (A7)+,D2
       rts
; }
; void Wait750ms(void)
; {
_Wait750ms:
       move.l    D2,-(A7)
; int i;
; for (i = 0; i < 750; i++)
       clr.l     D2
Wait750ms_1:
       cmp.l     #750,D2
       bge.s     Wait750ms_3
; Wait1ms();
       jsr       _Wait1ms
       addq.l    #1,D2
       bra       Wait750ms_1
Wait750ms_3:
       move.l    (A7)+,D2
       rts
; }
; void InstallExceptionHandler( void (*function_ptr)(), int level)
; {
_InstallExceptionHandler:
       link      A6,#-4
; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
       move.l    #134414336,-4(A6)
; RamVectorAddress[level] = (long int *)(function_ptr);
       move.l    -4(A6),A0
       move.l    12(A6),D0
       lsl.l     #2,D0
       move.l    8(A6),0(A0,D0.L)
       unlk      A6
       rts
; }
; void say_phoneme   (char phoneme_code) {
_say_phoneme:
       link      A6,#0
; //you need to write this function
; voice = phoneme_code;
       move.b    11(A6),-16711682
       unlk      A6
       rts
; }
; void say_Sasha(){
_say_Sasha:
; talkphonemeSS();
       jsr       _talkphonemeSS
; talkphonemeAA();
       jsr       _talkphonemeAA
; talkphonemeSH();
       jsr       _talkphonemeSH
; // talkphonemeHH1();
; talkphonemeAA();
       jsr       _talkphonemeAA
; endword();
       jsr       _endword
       rts
; }
; void say_hello() {
_say_hello:
; talkphonemeHH1();
       jsr       _talkphonemeHH1
; talkphonemeEH();
       jsr       _talkphonemeEH
; talkphonemeLL();
       jsr       _talkphonemeLL
; talkphonemeAX();
       jsr       _talkphonemeAX
; talkphonemeOW();
       jsr       _talkphonemeOW
; endword();
       jsr       _endword
       rts
; }
; void say_world() {
_say_world:
; talkphonemeWW();
       jsr       _talkphonemeWW
; talkphonemeER2();
       jsr       _talkphonemeER2
; talkphonemeLL();
       jsr       _talkphonemeLL
; talkphonemeDD1();
       jsr       _talkphonemeDD1
; endword();
       jsr       _endword
       rts
; }
; /*********************************************************************************************
; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
; *********************************************************************************************/
; void Init_RS232(void)
; {
_Init_RS232:
; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
       move.b    #21,4194368
; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
       move.b    #1,4194372
       rts
; }
; int kbhit(void)
; {
_kbhit:
; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
       move.b    4194368,D0
       and.b     #1,D0
       cmp.b     #1,D0
       bne.s     kbhit_1
; return 1 ;
       moveq     #1,D0
       bra.s     kbhit_3
kbhit_1:
; else
; return 0 ;
       clr.l     D0
kbhit_3:
       rts
; }
; /*********************************************************************************************************
; **  Subroutine to provide a low level output function to 6850 ACIA
; **  This routine provides the basic functionality to output a single character to the serial Port
; **  to allow the board to communicate with HyperTerminal Program
; **
; **  NOTE you do not call this function directly, instead you call the normal putchar() function
; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
; **  call _putch() also
; *********************************************************************************************************/
; int _putch( int c)
; {
__putch:
       link      A6,#0
; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
_putch_1:
       move.b    4194368,D0
       and.b     #2,D0
       cmp.b     #2,D0
       beq.s     _putch_3
       bra       _putch_1
_putch_3:
; ;
; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
       move.l    8(A6),D0
       and.b     #127,D0
       move.b    D0,4194370
; return c ;                                              // putchar() expects the character to be returned
       move.l    8(A6),D0
       unlk      A6
       rts
; }
; /*********************************************************************************************************
; **  Subroutine to provide a low level input function to 6850 ACIA
; **  This routine provides the basic functionality to input a single character from the serial Port
; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
; **
; **  NOTE you do not call this function directly, instead you call the normal _getch() function
; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
; **  call _getch() also
; *********************************************************************************************************/
; int _getch( void )
; {
__getch:
       move.l    D2,-(A7)
; int c ;
; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
_getch_1:
       move.b    4194368,D0
       and.b     #1,D0
       cmp.b     #1,D0
       beq.s     _getch_3
       bra       _getch_1
_getch_3:
; ;
; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
       move.b    4194370,D0
       and.l     #255,D0
       and.l     #127,D0
       move.l    D0,D2
; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
; if(Echo)
       tst.l     _Echo.L
       beq.s     _getch_4
; _putch(c);
       move.l    D2,-(A7)
       jsr       __putch
       addq.w    #4,A7
_getch_4:
; return c ;
       move.l    D2,D0
       move.l    (A7)+,D2
       rts
; }
; // flush the input stream for any unread characters
; void FlushKeyboard(void)
; {
_FlushKeyboard:
       link      A6,#-4
; char c ;
; while(1)    {
FlushKeyboard_1:
; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
       move.b    4194368,D0
       and.b     #1,D0
       cmp.b     #1,D0
       bne.s     FlushKeyboard_4
; c = ((char)(RS232_RxData) & (char)(0x7f)) ;
       move.b    4194370,D0
       and.b     #127,D0
       move.b    D0,-1(A6)
       bra.s     FlushKeyboard_5
FlushKeyboard_4:
; else
; return ;
       bra.s     FlushKeyboard_6
FlushKeyboard_5:
       bra       FlushKeyboard_1
FlushKeyboard_6:
       unlk      A6
       rts
; }
; }
; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
; // char assumed to be a valid hex char 0-9, a-f, A-F
; char xtod(int c)
; {
_xtod:
       link      A6,#0
       move.l    D2,-(A7)
       move.l    8(A6),D2
; if ((char)(c) <= (char)('9'))
       cmp.b     #57,D2
       bgt.s     xtod_1
; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
       move.b    D2,D0
       sub.b     #48,D0
       bra.s     xtod_3
xtod_1:
; else if((char)(c) > (char)('F'))    // assume lower case
       cmp.b     #70,D2
       ble.s     xtod_4
; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
       move.b    D2,D0
       sub.b     #87,D0
       bra.s     xtod_3
xtod_4:
; else
; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
       move.b    D2,D0
       sub.b     #55,D0
xtod_3:
       move.l    (A7)+,D2
       unlk      A6
       rts
; }
; int Get2HexDigits(char *CheckSumPtr)
; {
_Get2HexDigits:
       link      A6,#0
       move.l    D2,-(A7)
; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
       move.l    D0,-(A7)
       jsr       __getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _xtod
       addq.w    #4,A7
       and.l     #255,D0
       asl.l     #4,D0
       move.l    D0,-(A7)
       move.l    D1,-(A7)
       jsr       __getch
       move.l    (A7)+,D1
       move.l    D0,-(A7)
       jsr       _xtod
       addq.w    #4,A7
       move.l    D0,D1
       move.l    (A7)+,D0
       and.l     #255,D1
       or.l      D1,D0
       move.l    D0,D2
; if(CheckSumPtr)
       tst.l     8(A6)
       beq.s     Get2HexDigits_1
; *CheckSumPtr += i ;
       move.l    8(A6),A0
       add.b     D2,(A0)
Get2HexDigits_1:
; return i ;
       move.l    D2,D0
       move.l    (A7)+,D2
       unlk      A6
       rts
; }
; int Get4HexDigits(char *CheckSumPtr)
; {
_Get4HexDigits:
       link      A6,#0
; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
       move.l    8(A6),-(A7)
       jsr       _Get2HexDigits
       addq.w    #4,A7
       asl.l     #8,D0
       move.l    D0,-(A7)
       move.l    8(A6),-(A7)
       jsr       _Get2HexDigits
       addq.w    #4,A7
       move.l    D0,D1
       move.l    (A7)+,D0
       or.l      D1,D0
       unlk      A6
       rts
; }
; int Get6HexDigits(char *CheckSumPtr)
; {
_Get6HexDigits:
       link      A6,#0
; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
       move.l    8(A6),-(A7)
       jsr       _Get4HexDigits
       addq.w    #4,A7
       asl.l     #8,D0
       move.l    D0,-(A7)
       move.l    8(A6),-(A7)
       jsr       _Get2HexDigits
       addq.w    #4,A7
       move.l    D0,D1
       move.l    (A7)+,D0
       or.l      D1,D0
       unlk      A6
       rts
; }
; int Get8HexDigits(char *CheckSumPtr)
; {
_Get8HexDigits:
       link      A6,#0
; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
       move.l    8(A6),-(A7)
       jsr       _Get4HexDigits
       addq.w    #4,A7
       asl.l     #8,D0
       asl.l     #8,D0
       move.l    D0,-(A7)
       move.l    8(A6),-(A7)
       jsr       _Get4HexDigits
       addq.w    #4,A7
       move.l    D0,D1
       move.l    (A7)+,D0
       or.l      D1,D0
       unlk      A6
       rts
; }
; void DumpMemory(void)   // simple dump memory fn
; {
_DumpMemory:
       movem.l   D2/D3/D4/D5/A2/A3,-(A7)
       lea       _printf.L,A2
       lea       _putch.L,A3
; int i, j ;
; unsigned char *RamPtr,c ; // pointer to where the program is download (assumed)
; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue") ;
       pea       @m68kde~1_1.L
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\nEnter Start Address: ") ;
       pea       @m68kde~1_2.L
       jsr       (A2)
       addq.w    #4,A7
; RamPtr = Get8HexDigits(0) ;
       clr.l     -(A7)
       jsr       _Get8HexDigits
       addq.w    #4,A7
       move.l    D0,D3
; while(1)    {
DumpMemory_1:
; for(i = 0; i < 16; i ++)    {
       clr.l     D5
DumpMemory_4:
       cmp.l     #16,D5
       bge       DumpMemory_6
; printf("\r\n%08x ", RamPtr) ;
       move.l    D3,-(A7)
       pea       @m68kde~1_3.L
       jsr       (A2)
       addq.w    #8,A7
; for(j=0; j < 16; j ++)  {
       clr.l     D2
DumpMemory_7:
       cmp.l     #16,D2
       bge.s     DumpMemory_9
; printf("%02X",RamPtr[j]) ;
       move.l    D3,A0
       move.b    0(A0,D2.L),D1
       and.l     #255,D1
       move.l    D1,-(A7)
       pea       @m68kde~1_4.L
       jsr       (A2)
       addq.w    #8,A7
; putchar(' ') ;
       pea       32
       jsr       (A3)
       addq.w    #4,A7
       addq.l    #1,D2
       bra       DumpMemory_7
DumpMemory_9:
; }
; // now display the data as ASCII at the end
; printf("  ") ;
       pea       @m68kde~1_5.L
       jsr       (A2)
       addq.w    #4,A7
; for(j = 0; j < 16; j++) {
       clr.l     D2
DumpMemory_10:
       cmp.l     #16,D2
       bge       DumpMemory_12
; c = ((char)(RamPtr[j]) & 0x7f) ;
       move.l    D3,A0
       move.b    0(A0,D2.L),D0
       and.b     #127,D0
       move.b    D0,D4
; if((c > (char)(0x7f)) || (c < ' '))
       cmp.b     #127,D4
       bhi.s     DumpMemory_15
       cmp.b     #32,D4
       bhs.s     DumpMemory_13
DumpMemory_15:
; putchar('.') ;
       pea       46
       jsr       (A3)
       addq.w    #4,A7
       bra.s     DumpMemory_14
DumpMemory_13:
; else
; putchar(RamPtr[j]) ;
       move.l    D3,A0
       move.b    0(A0,D2.L),D1
       and.l     #255,D1
       move.l    D1,-(A7)
       jsr       (A3)
       addq.w    #4,A7
DumpMemory_14:
       addq.l    #1,D2
       bra       DumpMemory_10
DumpMemory_12:
; }
; RamPtr = RamPtr + 16 ;
       add.l     #16,D3
       addq.l    #1,D5
       bra       DumpMemory_4
DumpMemory_6:
; }
; printf("\r\n") ;
       pea       @m68kde~1_6.L
       jsr       (A2)
       addq.w    #4,A7
; c = _getch() ;
       jsr       __getch
       move.b    D0,D4
; if(c == 0x1b)          // break on ESC
       cmp.b     #27,D4
       bne.s     DumpMemory_16
; break ;
       bra.s     DumpMemory_3
DumpMemory_16:
       bra       DumpMemory_1
DumpMemory_3:
       movem.l   (A7)+,D2/D3/D4/D5/A2/A3
       rts
; }
; }
; void FillMemory()
; {
_FillMemory:
       movem.l   D2/D3/D4/A2,-(A7)
       lea       _printf.L,A2
; char *StartRamPtr, *EndRamPtr ;
; unsigned char FillData ;
; printf("\r\nFill Memory Block") ;
       pea       @m68kde~1_7.L
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\nEnter Start Address: ") ;
       pea       @m68kde~1_2.L
       jsr       (A2)
       addq.w    #4,A7
; StartRamPtr = Get8HexDigits(0) ;
       clr.l     -(A7)
       jsr       _Get8HexDigits
       addq.w    #4,A7
       move.l    D0,D2
; printf("\r\nEnter End Address: ") ;
       pea       @m68kde~1_8.L
       jsr       (A2)
       addq.w    #4,A7
; EndRamPtr = Get8HexDigits(0) ;
       clr.l     -(A7)
       jsr       _Get8HexDigits
       addq.w    #4,A7
       move.l    D0,D4
; printf("\r\nEnter Fill Data: ") ;
       pea       @m68kde~1_9.L
       jsr       (A2)
       addq.w    #4,A7
; FillData = Get2HexDigits(0) ;
       clr.l     -(A7)
       jsr       _Get2HexDigits
       addq.w    #4,A7
       move.b    D0,D3
; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData) ;
       and.l     #255,D3
       move.l    D3,-(A7)
       move.l    D4,-(A7)
       move.l    D2,-(A7)
       pea       @m68kde~1_10.L
       jsr       (A2)
       add.w     #16,A7
; while(StartRamPtr < EndRamPtr)
FillMemory_1:
       cmp.l     D4,D2
       bhs.s     FillMemory_3
; *StartRamPtr++ = FillData ;
       move.l    D2,A0
       addq.l    #1,D2
       move.b    D3,(A0)
       bra       FillMemory_1
FillMemory_3:
       movem.l   (A7)+,D2/D3/D4/A2
       rts
; }
; void Load_SRecordFile()
; {
_Load_SRecordFile:
       link      A6,#-36
       movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
       lea       -6(A6),A2
       lea       _Get2HexDigits.L,A3
       lea       _printf.L,A4
; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0 ;
       clr.l     -18(A6)
       move.w    #0,A5
; int result, ByteCount ;
; char c, CheckSum, ReadCheckSum, HeaderType ;
; char *RamPtr ;                          // pointer to Memory where downloaded program will be stored
; LoadFailed = 0 ;                        //assume LOAD operation will pass
       moveq     #0,D7
; AddressFail = 0 ;
       clr.l     -22(A6)
; Echo = 0 ;                              // don't echo S records during download
       clr.l     _Echo.L
; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n") ;
       pea       @m68kde~1_11.L
       jsr       (A4)
       addq.w    #4,A7
; while(1)    {
Load_SRecordFile_1:
; CheckSum = 0 ;
       clr.b     (A2)
; do {
Load_SRecordFile_4:
; c = toupper(_getch()) ;
       move.l    D0,-(A7)
       jsr       __getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _toupper
       addq.w    #4,A7
       move.b    D0,D6
; if(c == 0x1b )      // if break
       cmp.b     #27,D6
       bne.s     Load_SRecordFile_6
; return;
       bra       Load_SRecordFile_8
Load_SRecordFile_6:
       cmp.b     #83,D6
       bne       Load_SRecordFile_4
; }while(c != (char)('S'));   // wait for S start of header
; HeaderType = _getch() ;
       jsr       __getch
       move.b    D0,D3
; if(HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
       cmp.b     #48,D3
       beq.s     Load_SRecordFile_11
       cmp.b     #53,D3
       bne.s     Load_SRecordFile_9
Load_SRecordFile_11:
; continue ;
       bra       Load_SRecordFile_23
Load_SRecordFile_9:
; if(HeaderType >= (char)('7'))
       cmp.b     #55,D3
       blt.s     Load_SRecordFile_12
; break ;                 // end load on s7,s8,s9 records
       bra       Load_SRecordFile_3
Load_SRecordFile_12:
; // get the bytecount
; ByteCount = Get2HexDigits(&CheckSum) ;
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #4,A7
       move.l    D0,-10(A6)
; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
; if(HeaderType == (char)('1')) {
       cmp.b     #49,D3
       bne.s     Load_SRecordFile_14
; AddressSize = 2 ;       // 2 byte address
       moveq     #2,D5
; Address = Get4HexDigits(&CheckSum);
       move.l    A2,-(A7)
       jsr       _Get4HexDigits
       addq.w    #4,A7
       move.l    D0,D4
       bra.s     Load_SRecordFile_17
Load_SRecordFile_14:
; }
; else if (HeaderType == (char)('2')) {
       cmp.b     #50,D3
       bne.s     Load_SRecordFile_16
; AddressSize = 3 ;       // 3 byte address
       moveq     #3,D5
; Address = Get6HexDigits(&CheckSum) ;
       move.l    A2,-(A7)
       jsr       _Get6HexDigits
       addq.w    #4,A7
       move.l    D0,D4
       bra.s     Load_SRecordFile_17
Load_SRecordFile_16:
; }
; else    {
; AddressSize = 4 ;       // 4 byte address
       moveq     #4,D5
; Address = Get8HexDigits(&CheckSum) ;
       move.l    A2,-(A7)
       jsr       _Get8HexDigits
       addq.w    #4,A7
       move.l    D0,D4
Load_SRecordFile_17:
; }
; RamPtr = (char *)(Address) ;                            // point to download area
       move.l    D4,-4(A6)
; NumDataBytesToRead = ByteCount - AddressSize - 1 ;
       move.l    -10(A6),D0
       sub.l     D5,D0
       subq.l    #1,D0
       move.l    D0,-30(A6)
; for(i = 0; i < NumDataBytesToRead; i ++) {     // read in remaining data bytes (ignore address and checksum at the end
       clr.l     D2
Load_SRecordFile_18:
       cmp.l     -30(A6),D2
       bge.s     Load_SRecordFile_20
; DataByte = Get2HexDigits(&CheckSum) ;
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #4,A7
       move.l    D0,-34(A6)
; *RamPtr++ = DataByte ;                      // store downloaded byte in Ram at specified address
       move.l    -34(A6),D0
       move.l    -4(A6),A0
       addq.l    #1,-4(A6)
       move.b    D0,(A0)
; ByteTotal++;
       addq.w    #1,A5
       addq.l    #1,D2
       bra       Load_SRecordFile_18
Load_SRecordFile_20:
; }
; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
; ReadCheckSum = Get2HexDigits(0) ;
       clr.l     -(A7)
       jsr       (A3)
       addq.w    #4,A7
       move.b    D0,-5(A6)
; if((~CheckSum&0Xff) != (ReadCheckSum&0Xff))   {
       move.b    (A2),D0
       not.b     D0
       ext.w     D0
       and.w     #255,D0
       move.b    -5(A6),D1
       ext.w     D1
       and.w     #255,D1
       cmp.w     D1,D0
       beq.s     Load_SRecordFile_21
; LoadFailed = 1 ;
       moveq     #1,D7
; FailedAddress = Address ;
       move.l    D4,-26(A6)
; break;
       bra.s     Load_SRecordFile_3
Load_SRecordFile_21:
; }
; SRecordCount++ ;
       addq.l    #1,-18(A6)
; // display feedback on progress
; if(SRecordCount % 25 == 0)
       move.l    -18(A6),-(A7)
       pea       25
       jsr       LDIV
       move.l    4(A7),D0
       addq.w    #8,A7
       tst.l     D0
       bne.s     Load_SRecordFile_23
; putchar('.') ;
       pea       46
       jsr       _putch
       addq.w    #4,A7
Load_SRecordFile_23:
       bra       Load_SRecordFile_1
Load_SRecordFile_3:
; }
; if(LoadFailed == 1) {
       cmp.l     #1,D7
       bne.s     Load_SRecordFile_25
; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress) ;
       move.l    -26(A6),-(A7)
       pea       @m68kde~1_12.L
       jsr       (A4)
       addq.w    #8,A7
       bra.s     Load_SRecordFile_26
Load_SRecordFile_25:
; }
; else
; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal) ;
       move.l    A5,-(A7)
       pea       @m68kde~1_13.L
       jsr       (A4)
       addq.w    #8,A7
Load_SRecordFile_26:
; // pause at the end to wait for download to finish transmitting at the end of S8 etc
; for(i = 0; i < 400000; i ++)
       clr.l     D2
Load_SRecordFile_27:
       cmp.l     #400000,D2
       bge.s     Load_SRecordFile_29
       addq.l    #1,D2
       bra       Load_SRecordFile_27
Load_SRecordFile_29:
; ;
; FlushKeyboard() ;
       jsr       _FlushKeyboard
; Echo = 1;
       move.l    #1,_Echo.L
Load_SRecordFile_8:
       movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
       unlk      A6
       rts
; }
; void MemoryChange(void)
; {
_MemoryChange:
       movem.l   D2/D3/D4/A2,-(A7)
       lea       _printf.L,A2
; unsigned char *RamPtr,c ; // pointer to memory
; int Data ;
; printf("\r\nExamine and Change Memory") ;
       pea       @m68kde~1_14.L
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change") ;
       pea       @m68kde~1_15.L
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\nEnter Address: ") ;
       pea       @m68kde~1_16.L
       jsr       (A2)
       addq.w    #4,A7
; RamPtr = Get8HexDigits(0) ;
       clr.l     -(A7)
       jsr       _Get8HexDigits
       addq.w    #4,A7
       move.l    D0,D3
; while(1)    {
MemoryChange_1:
; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr) ;
       move.l    D3,A0
       move.b    (A0),D1
       and.l     #255,D1
       move.l    D1,-(A7)
       move.l    D3,-(A7)
       pea       @m68kde~1_17.L
       jsr       (A2)
       add.w     #12,A7
; c = tolower(_getch()) ;
       move.l    D0,-(A7)
       jsr       __getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _tolower
       addq.w    #4,A7
       move.b    D0,D2
; if(c == (char)(0x1b))
       cmp.b     #27,D2
       bne.s     MemoryChange_4
; return ;                                // abort on escape
       bra       MemoryChange_6
MemoryChange_4:
; else if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
       cmp.b     #48,D2
       blo.s     MemoryChange_10
       cmp.b     #57,D2
       bls.s     MemoryChange_9
MemoryChange_10:
       cmp.b     #97,D2
       blo       MemoryChange_7
       cmp.b     #102,D2
       bhi       MemoryChange_7
MemoryChange_9:
; Data = (xtod(c) << 4) | (xtod(_getch()));
       and.l     #255,D2
       move.l    D2,-(A7)
       jsr       _xtod
       addq.w    #4,A7
       and.l     #255,D0
       asl.l     #4,D0
       move.l    D0,-(A7)
       move.l    D1,-(A7)
       jsr       __getch
       move.l    (A7)+,D1
       move.l    D0,-(A7)
       jsr       _xtod
       addq.w    #4,A7
       move.l    D0,D1
       move.l    (A7)+,D0
       and.l     #255,D1
       or.l      D1,D0
       move.l    D0,D4
; *RamPtr = (char)(Data) ;
       move.l    D3,A0
       move.b    D4,(A0)
; if(*RamPtr != Data) {
       move.l    D3,A0
       move.b    (A0),D0
       and.l     #255,D0
       cmp.l     D4,D0
       beq.s     MemoryChange_11
; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr) ;
       move.l    D3,A0
       move.b    (A0),D1
       and.l     #255,D1
       move.l    D1,-(A7)
       move.l    D4,-(A7)
       pea       @m68kde~1_18.L
       jsr       (A2)
       add.w     #12,A7
MemoryChange_11:
       bra.s     MemoryChange_13
MemoryChange_7:
; }
; }
; else if(c == (char)('-'))
       cmp.b     #45,D2
       bne.s     MemoryChange_13
; RamPtr -= 2 ; ;
       subq.l    #2,D3
MemoryChange_13:
; RamPtr ++ ;
       addq.l    #1,D3
       bra       MemoryChange_1
MemoryChange_6:
       movem.l   (A7)+,D2/D3/D4/A2
       rts
; }
; }
; //////////////////////////////////////////////////////////////////////////////////////////////////
; // IMPORTANT
; // TG68 does not support the Native Trace mode of the original 68000 so tracing
; // has to be done with an interrupt (IRQ Level 6)
; //
; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
; //
; // on return from the IRQ service handler, the first access to the user memory program space
; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
; // execute one more new instruction (without it the TG68 would trace on the same instruction
; // each time and not after the next one). It also means it doesn't simgle step outside the user
; // program area
; //
; // The bottom line is the Trace handler, which includes the Dump registers below
; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
; /////////////////////////////////////////////////////////////////////////////////////////////////////
; void DumpRegisters()
; {
_DumpRegisters:
       movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
       lea       _putch.L,A2
       lea       _printf.L,A3
       lea       _SR.L,A4
       lea       _WatchPointString.L,A5
; short i, x, j, k ;
; unsigned char c, *BytePointer;
; // buld up strings for displaying watchpoints
; for(x = 0; x < (short)(8); x++)
       clr.w     D2
DumpRegisters_1:
       cmp.w     #8,D2
       bge       DumpRegisters_3
; {
; if(WatchPointSetOrCleared[x] == 1)
       ext.l     D2
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointSetOrCleared.L,A0
       move.l    0(A0,D0.L),D0
       cmp.l     #1,D0
       bne       DumpRegisters_4
; {
; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]) ;
       ext.l     D2
       move.l    D2,D1
       lsl.l     #2,D1
       lea       _WatchPointAddress.L,A0
       move.l    0(A0,D1.L),-(A7)
       pea       @m68kde~1_19.L
       move.l    A5,D1
       ext.l     D2
       move.l    D0,-(A7)
       move.l    D2,D0
       muls      #100,D0
       add.l     D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _sprintf
       add.w     #12,A7
; BytePointer = (char *)(WatchPointAddress[x]) ;
       ext.l     D2
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointAddress.L,A0
       move.l    0(A0,D0.L),D5
; for(j = 0; j < (short)(16); j+=2)
       clr.w     D3
DumpRegisters_6:
       cmp.w     #16,D3
       bge       DumpRegisters_8
; {
; for(k = 0; k < (short)(2); k++)
       clr.w     D6
DumpRegisters_9:
       cmp.w     #2,D6
       bge       DumpRegisters_11
; {
; sprintf(TempString, "%02X", BytePointer[j+k]) ;
       move.l    D5,A0
       ext.l     D3
       move.l    D3,D1
       ext.l     D6
       add.l     D6,D1
       move.b    0(A0,D1.L),D1
       and.l     #255,D1
       move.l    D1,-(A7)
       pea       @m68kde~1_4.L
       pea       _TempString.L
       jsr       _sprintf
       add.w     #12,A7
; strcat(WatchPointString[x], TempString) ;
       pea       _TempString.L
       move.l    A5,D1
       ext.l     D2
       move.l    D0,-(A7)
       move.l    D2,D0
       muls      #100,D0
       add.l     D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _strcat
       addq.w    #8,A7
       addq.w    #1,D6
       bra       DumpRegisters_9
DumpRegisters_11:
; }
; strcat(WatchPointString[x]," ") ;
       pea       @m68kde~1_20.L
       move.l    A5,D1
       ext.l     D2
       move.l    D0,-(A7)
       move.l    D2,D0
       muls      #100,D0
       add.l     D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _strcat
       addq.w    #8,A7
       addq.w    #2,D3
       bra       DumpRegisters_6
DumpRegisters_8:
; }
; strcat(WatchPointString[x], "  ") ;
       pea       @m68kde~1_5.L
       move.l    A5,D1
       ext.l     D2
       move.l    D0,-(A7)
       move.l    D2,D0
       muls      #100,D0
       add.l     D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _strcat
       addq.w    #8,A7
; BytePointer = (char *)(WatchPointAddress[x]) ;
       ext.l     D2
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointAddress.L,A0
       move.l    0(A0,D0.L),D5
; for(j = 0; j < (short)(16); j++)
       clr.w     D3
DumpRegisters_12:
       cmp.w     #16,D3
       bge       DumpRegisters_14
; {
; c = ((char)(BytePointer[j]) & 0x7f) ;
       move.l    D5,A0
       ext.l     D3
       move.b    0(A0,D3.L),D0
       and.b     #127,D0
       move.b    D0,D7
; if((c > (char)(0x7f)) || (c < (char)(' ')))
       cmp.b     #127,D7
       bhi.s     DumpRegisters_17
       cmp.b     #32,D7
       bhs.s     DumpRegisters_15
DumpRegisters_17:
; sprintf(TempString, ".") ;
       pea       @m68kde~1_21.L
       pea       _TempString.L
       jsr       _sprintf
       addq.w    #8,A7
       bra.s     DumpRegisters_16
DumpRegisters_15:
; else
; sprintf(TempString, "%c", BytePointer[j]) ;
       move.l    D5,A0
       ext.l     D3
       move.b    0(A0,D3.L),D1
       and.l     #255,D1
       move.l    D1,-(A7)
       pea       @m68kde~1_22.L
       pea       _TempString.L
       jsr       _sprintf
       add.w     #12,A7
DumpRegisters_16:
; strcat(WatchPointString[x], TempString) ;
       pea       _TempString.L
       move.l    A5,D1
       ext.l     D2
       move.l    D0,-(A7)
       move.l    D2,D0
       muls      #100,D0
       add.l     D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _strcat
       addq.w    #8,A7
       addq.w    #1,D3
       bra       DumpRegisters_12
DumpRegisters_14:
       bra.s     DumpRegisters_5
DumpRegisters_4:
; }
; }
; else
; strcpy(WatchPointString[x], "") ;
       pea       @m68kde~1_23.L
       move.l    A5,D1
       ext.l     D2
       move.l    D0,-(A7)
       move.l    D2,D0
       muls      #100,D0
       add.l     D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _strcpy
       addq.w    #8,A7
DumpRegisters_5:
       addq.w    #1,D2
       bra       DumpRegisters_1
DumpRegisters_3:
; }
; printf("\r\n\r\n D0 = $%08X  A0 = $%08X",d0,a0) ;
       move.l    _a0.L,-(A7)
       move.l    _d0.L,-(A7)
       pea       @m68kde~1_24.L
       jsr       (A3)
       add.w     #12,A7
; printf("\r\n D1 = $%08X  A1 = $%08X",d1,a1) ;
       move.l    _a1.L,-(A7)
       move.l    _d1.L,-(A7)
       pea       @m68kde~1_25.L
       jsr       (A3)
       add.w     #12,A7
; printf("\r\n D2 = $%08X  A2 = $%08X",d2,a2) ;
       move.l    _a2.L,-(A7)
       move.l    _d2.L,-(A7)
       pea       @m68kde~1_26.L
       jsr       (A3)
       add.w     #12,A7
; printf("\r\n D3 = $%08X  A3 = $%08X",d3,a3) ;
       move.l    _a3.L,-(A7)
       move.l    _d3.L,-(A7)
       pea       @m68kde~1_27.L
       jsr       (A3)
       add.w     #12,A7
; printf("\r\n D4 = $%08X  A4 = $%08X",d4,a4) ;
       move.l    _a4.L,-(A7)
       move.l    _d4.L,-(A7)
       pea       @m68kde~1_28.L
       jsr       (A3)
       add.w     #12,A7
; printf("\r\n D5 = $%08X  A5 = $%08X",d5,a5) ;
       move.l    _a5.L,-(A7)
       move.l    _d5.L,-(A7)
       pea       @m68kde~1_29.L
       jsr       (A3)
       add.w     #12,A7
; printf("\r\n D6 = $%08X  A6 = $%08X",d6,a6) ;
       move.l    _a6.L,-(A7)
       move.l    _d6.L,-(A7)
       pea       @m68kde~1_30.L
       jsr       (A3)
       add.w     #12,A7
; printf("\r\n D7 = $%08X  A7 = $%08X",d7,((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP) ;
       move.w    (A4),D1
       and.w     #8192,D1
       cmp.w     #8192,D1
       bne.s     DumpRegisters_18
       move.l    _SSP.L,D1
       bra.s     DumpRegisters_19
DumpRegisters_18:
       move.l    _USP.L,D1
DumpRegisters_19:
       move.l    D1,-(A7)
       move.l    _d7.L,-(A7)
       pea       @m68kde~1_31.L
       jsr       (A3)
       add.w     #12,A7
; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP ) ;
       move.l    _USP.L,-(A7)
       pea       @m68kde~1_32.L
       jsr       (A3)
       addq.w    #8,A7
; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP) ;
       move.l    _SSP.L,-(A7)
       pea       @m68kde~1_33.L
       jsr       (A3)
       addq.w    #8,A7
; printf("\r\n SR = $%04X   ",SR) ;
       move.w    (A4),D1
       and.l     #65535,D1
       move.l    D1,-(A7)
       pea       @m68kde~1_34.L
       jsr       (A3)
       addq.w    #8,A7
; // display the status word in characters etc.
; printf("   [") ;
       pea       @m68kde~1_35.L
       jsr       (A3)
       addq.w    #4,A7
; if((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T') ; else putchar('-') ;      // Trace bit(bit 15)
       move.w    (A4),D0
       and.w     #32768,D0
       cmp.w     #32768,D0
       bne.s     DumpRegisters_20
       pea       84
       jsr       (A2)
       addq.w    #4,A7
       bra.s     DumpRegisters_21
DumpRegisters_20:
       pea       45
       jsr       (A2)
       addq.w    #4,A7
DumpRegisters_21:
; if((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S') ; else putchar('U') ;      // supervisor bit  (bit 13)
       move.w    (A4),D0
       and.w     #8192,D0
       cmp.w     #8192,D0
       bne.s     DumpRegisters_22
       pea       83
       jsr       (A2)
       addq.w    #4,A7
       bra.s     DumpRegisters_23
DumpRegisters_22:
       pea       85
       jsr       (A2)
       addq.w    #4,A7
DumpRegisters_23:
; if((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1') ; else putchar('0') ;      // IRQ2 Bit (bit 10)
       move.w    (A4),D0
       and.w     #1024,D0
       cmp.w     #1024,D0
       bne.s     DumpRegisters_24
       pea       49
       jsr       (A2)
       addq.w    #4,A7
       bra.s     DumpRegisters_25
DumpRegisters_24:
       pea       48
       jsr       (A2)
       addq.w    #4,A7
DumpRegisters_25:
; if((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1') ; else putchar('0') ;      // IRQ1 Bit (bit 9)
       move.w    (A4),D0
       and.w     #512,D0
       cmp.w     #512,D0
       bne.s     DumpRegisters_26
       pea       49
       jsr       (A2)
       addq.w    #4,A7
       bra.s     DumpRegisters_27
DumpRegisters_26:
       pea       48
       jsr       (A2)
       addq.w    #4,A7
DumpRegisters_27:
; if((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1') ; else putchar('0') ;      // IRQ0 Bit (bit 8)
       move.w    (A4),D0
       and.w     #256,D0
       cmp.w     #256,D0
       bne.s     DumpRegisters_28
       pea       49
       jsr       (A2)
       addq.w    #4,A7
       bra.s     DumpRegisters_29
DumpRegisters_28:
       pea       48
       jsr       (A2)
       addq.w    #4,A7
DumpRegisters_29:
; if((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X') ; else putchar('-') ;      // X Bit (bit 4)
       move.w    (A4),D0
       and.w     #16,D0
       cmp.w     #16,D0
       bne.s     DumpRegisters_30
       pea       88
       jsr       (A2)
       addq.w    #4,A7
       bra.s     DumpRegisters_31
DumpRegisters_30:
       pea       45
       jsr       (A2)
       addq.w    #4,A7
DumpRegisters_31:
; if((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N') ; else putchar('-') ;      // N Bit (bit 3)
       move.w    (A4),D0
       and.w     #8,D0
       cmp.w     #8,D0
       bne.s     DumpRegisters_32
       pea       78
       jsr       (A2)
       addq.w    #4,A7
       bra.s     DumpRegisters_33
DumpRegisters_32:
       pea       45
       jsr       (A2)
       addq.w    #4,A7
DumpRegisters_33:
; if((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z') ; else putchar('-') ;      // Z Bit (bit 2)
       move.w    (A4),D0
       and.w     #4,D0
       cmp.w     #4,D0
       bne.s     DumpRegisters_34
       pea       90
       jsr       (A2)
       addq.w    #4,A7
       bra.s     DumpRegisters_35
DumpRegisters_34:
       pea       45
       jsr       (A2)
       addq.w    #4,A7
DumpRegisters_35:
; if((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V') ; else putchar('-') ;      // V Bit (bit 1)
       move.w    (A4),D0
       and.w     #2,D0
       cmp.w     #2,D0
       bne.s     DumpRegisters_36
       pea       86
       jsr       (A2)
       addq.w    #4,A7
       bra.s     DumpRegisters_37
DumpRegisters_36:
       pea       45
       jsr       (A2)
       addq.w    #4,A7
DumpRegisters_37:
; if((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C') ; else putchar('-') ;      // C Bit (bit 0)
       move.w    (A4),D0
       and.w     #1,D0
       cmp.w     #1,D0
       bne.s     DumpRegisters_38
       pea       67
       jsr       (A2)
       addq.w    #4,A7
       bra.s     DumpRegisters_39
DumpRegisters_38:
       pea       45
       jsr       (A2)
       addq.w    #4,A7
DumpRegisters_39:
; putchar(']') ;
       pea       93
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\n PC = $%08X  ", PC) ;
       move.l    _PC.L,-(A7)
       pea       @m68kde~1_36.L
       jsr       (A3)
       addq.w    #8,A7
; if(*(unsigned short int *)(PC) == 0x4e4e)
       move.l    _PC.L,D0
       move.l    D0,A0
       move.w    (A0),D0
       cmp.w     #20046,D0
       bne.s     DumpRegisters_40
; printf("[@ BREAKPOINT]") ;
       pea       @m68kde~1_37.L
       jsr       (A3)
       addq.w    #4,A7
DumpRegisters_40:
; printf("\r\n") ;
       pea       @m68kde~1_6.L
       jsr       (A3)
       addq.w    #4,A7
; for(i=0; i < 8; i++)    {
       clr.w     D4
DumpRegisters_42:
       cmp.w     #8,D4
       bge       DumpRegisters_44
; if(WatchPointSetOrCleared[i] == 1)
       ext.l     D4
       move.l    D4,D0
       lsl.l     #2,D0
       lea       _WatchPointSetOrCleared.L,A0
       move.l    0(A0,D0.L),D0
       cmp.l     #1,D0
       bne.s     DumpRegisters_45
; printf("\r\nWP%d = %s", i, WatchPointString[i]) ;
       move.l    A5,D1
       ext.l     D4
       move.l    D0,-(A7)
       move.l    D4,D0
       muls      #100,D0
       add.l     D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       ext.l     D4
       move.l    D4,-(A7)
       pea       @m68kde~1_38.L
       jsr       (A3)
       add.w     #12,A7
DumpRegisters_45:
       addq.w    #1,D4
       bra       DumpRegisters_42
DumpRegisters_44:
       movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
       rts
; }
; }
; // Trace Exception Handler
; void DumpRegistersandPause(void)
; {
_DumpRegistersandPause:
       move.l    A2,-(A7)
       lea       _printf.L,A2
; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]") ;
       pea       @m68kde~1_39.L
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\nBreak Points :[Disabled]") ;
       pea       @m68kde~1_40.L
       jsr       (A2)
       addq.w    #4,A7
; DumpRegisters() ;
       jsr       _DumpRegisters
; printf("\r\nPress <SPACE> to Execute Next Instruction");
       pea       @m68kde~1_41.L
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\nPress <ESC> to Resume Program") ;
       pea       @m68kde~1_42.L
       jsr       (A2)
       addq.w    #4,A7
; menu() ;
       jsr       _menu
       move.l    (A7)+,A2
       rts
; }
; void ChangeRegisters(void)
; {
_ChangeRegisters:
       link      A6,#-4
       movem.l   D2/D3/A2/A3/A4/A5,-(A7)
       lea       _printf.L,A2
       lea       -4(A6),A3
       lea       _Get8HexDigits.L,A4
       lea       __getch.L,A5
; // get register name d0-d7, a0-a7, up, sp, sr, pc
; int reg_val ;
; char c, reg[3] ;
; reg[0] = tolower(_getch()) ;
       move.l    D0,-(A7)
       jsr       (A5)
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _tolower
       addq.w    #4,A7
       move.b    D0,(A3)
; reg[1] = c = tolower(_getch()) ;
       move.l    D0,-(A7)
       jsr       (A5)
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _tolower
       addq.w    #4,A7
       move.b    D0,D2
       move.b    D0,1(A3)
; if(reg[0] == (char)('d'))  {    // change data register
       move.b    (A3),D0
       cmp.b     #100,D0
       bne       ChangeRegisters_1
; if((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
       move.b    1(A3),D0
       cmp.b     #55,D0
       bgt.s     ChangeRegisters_5
       move.b    1(A3),D0
       cmp.b     #48,D0
       bge.s     ChangeRegisters_3
ChangeRegisters_5:
; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n") ;
       pea       @m68kde~1_43.L
       jsr       (A2)
       addq.w    #4,A7
; return ;
       bra       ChangeRegisters_6
ChangeRegisters_3:
; }
; else {
; printf("\r\nD%c = ", c) ;
       ext.w     D2
       ext.l     D2
       move.l    D2,-(A7)
       pea       @m68kde~1_44.L
       jsr       (A2)
       addq.w    #8,A7
; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
       clr.l     -(A7)
       jsr       (A4)
       addq.w    #4,A7
       move.l    D0,D3
; }
; // bit cludgy but d0-d7 not stored as an array for good reason
; if(c == (char)('0'))
       cmp.b     #48,D2
       bne.s     ChangeRegisters_7
; d0 = reg_val ;
       move.l    D3,_d0.L
       bra       ChangeRegisters_20
ChangeRegisters_7:
; else if(c == (char)('1'))
       cmp.b     #49,D2
       bne.s     ChangeRegisters_9
; d1 = reg_val ;
       move.l    D3,_d1.L
       bra       ChangeRegisters_20
ChangeRegisters_9:
; else if(c == (char)('2'))
       cmp.b     #50,D2
       bne.s     ChangeRegisters_11
; d2 = reg_val ;
       move.l    D3,_d2.L
       bra       ChangeRegisters_20
ChangeRegisters_11:
; else if(c == (char)('3'))
       cmp.b     #51,D2
       bne.s     ChangeRegisters_13
; d3 = reg_val ;
       move.l    D3,_d3.L
       bra.s     ChangeRegisters_20
ChangeRegisters_13:
; else if(c == (char)('4'))
       cmp.b     #52,D2
       bne.s     ChangeRegisters_15
; d4 = reg_val ;
       move.l    D3,_d4.L
       bra.s     ChangeRegisters_20
ChangeRegisters_15:
; else if(c == (char)('5'))
       cmp.b     #53,D2
       bne.s     ChangeRegisters_17
; d5 = reg_val ;
       move.l    D3,_d5.L
       bra.s     ChangeRegisters_20
ChangeRegisters_17:
; else if(c == (char)('6'))
       cmp.b     #54,D2
       bne.s     ChangeRegisters_19
; d6 = reg_val ;
       move.l    D3,_d6.L
       bra.s     ChangeRegisters_20
ChangeRegisters_19:
; else
; d7 = reg_val ;
       move.l    D3,_d7.L
ChangeRegisters_20:
       bra       ChangeRegisters_51
ChangeRegisters_1:
; }
; else if(reg[0] == (char)('a'))  {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
       move.b    (A3),D0
       cmp.b     #97,D0
       bne       ChangeRegisters_21
; if((c > (char)('7')) || (c < (char)('0'))) {
       cmp.b     #55,D2
       bgt.s     ChangeRegisters_25
       cmp.b     #48,D2
       bge.s     ChangeRegisters_23
ChangeRegisters_25:
; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n") ;
       pea       @m68kde~1_45.L
       jsr       (A2)
       addq.w    #4,A7
; return ;
       bra       ChangeRegisters_6
ChangeRegisters_23:
; }
; else {
; printf("\r\nA%c = ", c) ;
       ext.w     D2
       ext.l     D2
       move.l    D2,-(A7)
       pea       @m68kde~1_46.L
       jsr       (A2)
       addq.w    #8,A7
; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
       clr.l     -(A7)
       jsr       (A4)
       addq.w    #4,A7
       move.l    D0,D3
; }
; // bit cludgy but a0-a7 not stored as an array for good reason
; if(c == (char)('0'))
       cmp.b     #48,D2
       bne.s     ChangeRegisters_26
; a0 = reg_val ;
       move.l    D3,_a0.L
       bra       ChangeRegisters_39
ChangeRegisters_26:
; else if(c == (char)('1'))
       cmp.b     #49,D2
       bne.s     ChangeRegisters_28
; a1 = reg_val ;
       move.l    D3,_a1.L
       bra       ChangeRegisters_39
ChangeRegisters_28:
; else if(c == (char)('2'))
       cmp.b     #50,D2
       bne.s     ChangeRegisters_30
; a2 = reg_val ;
       move.l    D3,_a2.L
       bra       ChangeRegisters_39
ChangeRegisters_30:
; else if(c == (char)('3'))
       cmp.b     #51,D2
       bne.s     ChangeRegisters_32
; a3 = reg_val ;
       move.l    D3,_a3.L
       bra.s     ChangeRegisters_39
ChangeRegisters_32:
; else if(c == (char)('4'))
       cmp.b     #52,D2
       bne.s     ChangeRegisters_34
; a4 = reg_val ;
       move.l    D3,_a4.L
       bra.s     ChangeRegisters_39
ChangeRegisters_34:
; else if(c == (char)('5'))
       cmp.b     #53,D2
       bne.s     ChangeRegisters_36
; a5 = reg_val ;
       move.l    D3,_a5.L
       bra.s     ChangeRegisters_39
ChangeRegisters_36:
; else if(c == (char)('6'))
       cmp.b     #54,D2
       bne.s     ChangeRegisters_38
; a6 = reg_val ;
       move.l    D3,_a6.L
       bra.s     ChangeRegisters_39
ChangeRegisters_38:
; else
; USP = reg_val ;
       move.l    D3,_USP.L
ChangeRegisters_39:
       bra       ChangeRegisters_51
ChangeRegisters_21:
; }
; else if((reg[0] == (char)('u')) && (c == (char)('s')))  {
       move.b    (A3),D0
       cmp.b     #117,D0
       bne       ChangeRegisters_40
       cmp.b     #115,D2
       bne       ChangeRegisters_40
; if(tolower(_getch()) == 'p')  {    // change user stack pointer
       move.l    D0,-(A7)
       jsr       (A5)
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _tolower
       addq.w    #4,A7
       cmp.l     #112,D0
       bne.s     ChangeRegisters_42
; printf("\r\nUser SP = ") ;
       pea       @m68kde~1_47.L
       jsr       (A2)
       addq.w    #4,A7
; USP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
       clr.l     -(A7)
       jsr       (A4)
       addq.w    #4,A7
       move.l    D0,_USP.L
       bra.s     ChangeRegisters_43
ChangeRegisters_42:
; }
; else {
; printf("\r\nIllegal Register....") ;
       pea       @m68kde~1_48.L
       jsr       (A2)
       addq.w    #4,A7
; return ;
       bra       ChangeRegisters_6
ChangeRegisters_43:
       bra       ChangeRegisters_51
ChangeRegisters_40:
; }
; }
; else if((reg[0] == (char)('s')) && (c == (char)('s')))  {
       move.b    (A3),D0
       cmp.b     #115,D0
       bne       ChangeRegisters_44
       cmp.b     #115,D2
       bne       ChangeRegisters_44
; if(tolower(_getch()) == 'p')  {    // change system stack pointer
       move.l    D0,-(A7)
       jsr       (A5)
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _tolower
       addq.w    #4,A7
       cmp.l     #112,D0
       bne.s     ChangeRegisters_46
; printf("\r\nSystem SP = ") ;
       pea       @m68kde~1_49.L
       jsr       (A2)
       addq.w    #4,A7
; SSP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
       clr.l     -(A7)
       jsr       (A4)
       addq.w    #4,A7
       move.l    D0,_SSP.L
       bra.s     ChangeRegisters_47
ChangeRegisters_46:
; }
; else {
; printf("\r\nIllegal Register....") ;
       pea       @m68kde~1_48.L
       jsr       (A2)
       addq.w    #4,A7
; return ;
       bra       ChangeRegisters_6
ChangeRegisters_47:
       bra       ChangeRegisters_51
ChangeRegisters_44:
; }
; }
; else if((reg[0] == (char)('p')) && (c == (char)('c')))  {    // change program counter
       move.b    (A3),D0
       cmp.b     #112,D0
       bne.s     ChangeRegisters_48
       cmp.b     #99,D2
       bne.s     ChangeRegisters_48
; printf("\r\nPC = ") ;
       pea       @m68kde~1_50.L
       jsr       (A2)
       addq.w    #4,A7
; PC = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
       clr.l     -(A7)
       jsr       (A4)
       addq.w    #4,A7
       move.l    D0,_PC.L
       bra       ChangeRegisters_51
ChangeRegisters_48:
; }
; else if((reg[0] == (char)('s')) && (c == (char)('r')))  {    // change status register
       move.b    (A3),D0
       cmp.b     #115,D0
       bne.s     ChangeRegisters_50
       cmp.b     #114,D2
       bne.s     ChangeRegisters_50
; printf("\r\nSR = ") ;
       pea       @m68kde~1_51.L
       jsr       (A2)
       addq.w    #4,A7
; SR = Get4HexDigits(0) ;    // read 16 bit value from user keyboard
       clr.l     -(A7)
       jsr       _Get4HexDigits
       addq.w    #4,A7
       move.w    D0,_SR.L
       bra.s     ChangeRegisters_51
ChangeRegisters_50:
; }
; else
; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n") ;
       pea       @m68kde~1_52.L
       jsr       (A2)
       addq.w    #4,A7
ChangeRegisters_51:
; DumpRegisters() ;
       jsr       _DumpRegisters
ChangeRegisters_6:
       movem.l   (A7)+,D2/D3/A2/A3/A4/A5
       unlk      A6
       rts
; }
; void BreakPointDisplay(void)
; {
_BreakPointDisplay:
       movem.l   D2/D3/A2/A3,-(A7)
       lea       _printf.L,A2
       lea       _BreakPointAddress.L,A3
; int i, BreakPointsSet = 0 ;
       clr.l     D3
; // any break points  set
; for(i = 0; i < 8; i++)  {
       clr.l     D2
BreakPointDisplay_1:
       cmp.l     #8,D2
       bge.s     BreakPointDisplay_3
; if(BreakPointSetOrCleared[i] == 1)
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointSetOrCleared.L,A0
       move.l    0(A0,D0.L),D0
       cmp.l     #1,D0
       bne.s     BreakPointDisplay_4
; BreakPointsSet = 1;
       moveq     #1,D3
BreakPointDisplay_4:
       addq.l    #1,D2
       bra       BreakPointDisplay_1
BreakPointDisplay_3:
; }
; if(BreakPointsSet == 1) {
       cmp.l     #1,D3
       bne.s     BreakPointDisplay_6
; printf("\r\n\r\nNum     Address      Instruction") ;
       pea       @m68kde~1_53.L
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\n---     ---------    -----------") ;
       pea       @m68kde~1_54.L
       jsr       (A2)
       addq.w    #4,A7
       bra.s     BreakPointDisplay_7
BreakPointDisplay_6:
; }
; else
; printf("\r\nNo BreakPoints Set") ;
       pea       @m68kde~1_55.L
       jsr       (A2)
       addq.w    #4,A7
BreakPointDisplay_7:
; for(i = 0; i < 8; i++)  {
       clr.l     D2
BreakPointDisplay_8:
       cmp.l     #8,D2
       bge       BreakPointDisplay_10
; // put opcode back, then put break point back
; if(BreakPointSetOrCleared[i] == 1)  {
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointSetOrCleared.L,A0
       move.l    0(A0,D0.L),D0
       cmp.l     #1,D0
       bne       BreakPointDisplay_11
; *(unsigned short int *)(BreakPointAddress[i]) = BreakPointInstruction[i];
       move.l    D2,D0
       lsl.l     #1,D0
       lea       _BreakPointInstruction.L,A0
       move.l    D2,D1
       lsl.l     #2,D1
       move.l    0(A3,D1.L),D1
       move.l    D1,A1
       move.w    0(A0,D0.L),(A1)
; *(unsigned short int *)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e) ;
       move.l    D2,D0
       lsl.l     #2,D0
       move.l    0(A3,D0.L),D0
       move.l    D0,A0
       move.w    #20046,(A0)
; printf("\r\n%3d     $%08x",i, BreakPointAddress[i]) ;
       move.l    D2,D1
       lsl.l     #2,D1
       move.l    0(A3,D1.L),-(A7)
       move.l    D2,-(A7)
       pea       @m68kde~1_56.L
       jsr       (A2)
       add.w     #12,A7
BreakPointDisplay_11:
       addq.l    #1,D2
       bra       BreakPointDisplay_8
BreakPointDisplay_10:
; }
; }
; printf("\r\n") ;
       pea       @m68kde~1_6.L
       jsr       (A2)
       addq.w    #4,A7
       movem.l   (A7)+,D2/D3/A2/A3
       rts
; }
; void WatchPointDisplay(void)
; {
_WatchPointDisplay:
       movem.l   D2/D3/A2,-(A7)
       lea       _printf.L,A2
; int i ;
; int WatchPointsSet = 0 ;
       clr.l     D3
; // any watchpoints set
; for(i = 0; i < 8; i++)  {
       clr.l     D2
WatchPointDisplay_1:
       cmp.l     #8,D2
       bge.s     WatchPointDisplay_3
; if(WatchPointSetOrCleared[i] == 1)
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointSetOrCleared.L,A0
       move.l    0(A0,D0.L),D0
       cmp.l     #1,D0
       bne.s     WatchPointDisplay_4
; WatchPointsSet = 1;
       moveq     #1,D3
WatchPointDisplay_4:
       addq.l    #1,D2
       bra       WatchPointDisplay_1
WatchPointDisplay_3:
; }
; if(WatchPointsSet == 1) {
       cmp.l     #1,D3
       bne.s     WatchPointDisplay_6
; printf("\r\nNum     Address") ;
       pea       @m68kde~1_57.L
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\n---     ---------") ;
       pea       @m68kde~1_58.L
       jsr       (A2)
       addq.w    #4,A7
       bra.s     WatchPointDisplay_7
WatchPointDisplay_6:
; }
; else
; printf("\r\nNo WatchPoints Set") ;
       pea       @m68kde~1_59.L
       jsr       (A2)
       addq.w    #4,A7
WatchPointDisplay_7:
; for(i = 0; i < 8; i++)  {
       clr.l     D2
WatchPointDisplay_8:
       cmp.l     #8,D2
       bge       WatchPointDisplay_10
; if(WatchPointSetOrCleared[i] == 1)
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointSetOrCleared.L,A0
       move.l    0(A0,D0.L),D0
       cmp.l     #1,D0
       bne.s     WatchPointDisplay_11
; printf("\r\n%3d     $%08x",i, WatchPointAddress[i]) ;
       move.l    D2,D1
       lsl.l     #2,D1
       lea       _WatchPointAddress.L,A0
       move.l    0(A0,D1.L),-(A7)
       move.l    D2,-(A7)
       pea       @m68kde~1_56.L
       jsr       (A2)
       add.w     #12,A7
WatchPointDisplay_11:
       addq.l    #1,D2
       bra       WatchPointDisplay_8
WatchPointDisplay_10:
; }
; printf("\r\n") ;
       pea       @m68kde~1_6.L
       jsr       (A2)
       addq.w    #4,A7
       movem.l   (A7)+,D2/D3/A2
       rts
; }
; void BreakPointClear(void)
; {
_BreakPointClear:
       link      A6,#-4
       movem.l   D2/A2,-(A7)
       lea       _printf.L,A2
; unsigned int i ;
; volatile unsigned short int *ProgramBreakPointAddress ;
; BreakPointDisplay() ;
       jsr       _BreakPointDisplay
; printf("\r\nEnter Break Point Number: ") ;
       pea       @m68kde~1_60.L
       jsr       (A2)
       addq.w    #4,A7
; i = xtod(_getch()) ;           // get break pointer number
       move.l    D0,-(A7)
       jsr       __getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _xtod
       addq.w    #4,A7
       and.l     #255,D0
       move.l    D0,D2
; if((i < 0) || (i > 7))   {
       cmp.l     #0,D2
       blo.s     BreakPointClear_3
       cmp.l     #7,D2
       bls.s     BreakPointClear_1
BreakPointClear_3:
; printf("\r\nIllegal Range : Use 0 - 7") ;
       pea       @m68kde~1_61.L
       jsr       (A2)
       addq.w    #4,A7
; return ;
       bra       BreakPointClear_4
BreakPointClear_1:
; }
; if(BreakPointSetOrCleared[i] == 1)  {       // if break point set
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointSetOrCleared.L,A0
       move.l    0(A0,D0.L),D0
       cmp.l     #1,D0
       bne       BreakPointClear_5
; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program we are about to change
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       move.l    0(A0,D0.L),-4(A6)
; BreakPointAddress[i] = 0 ;
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       clr.l     0(A0,D0.L)
; BreakPointSetOrCleared[i] = 0 ;
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointSetOrCleared.L,A0
       clr.l     0(A0,D0.L)
; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
       move.l    D2,D0
       lsl.l     #1,D0
       lea       _BreakPointInstruction.L,A0
       move.l    -4(A6),A1
       move.w    0(A0,D0.L),(A1)
; BreakPointInstruction[i] = 0 ;
       move.l    D2,D0
       lsl.l     #1,D0
       lea       _BreakPointInstruction.L,A0
       clr.w     0(A0,D0.L)
; printf("\r\nBreak Point Cleared.....\r\n") ;
       pea       @m68kde~1_62.L
       jsr       (A2)
       addq.w    #4,A7
       bra.s     BreakPointClear_6
BreakPointClear_5:
; }
; else
; printf("\r\nBreak Point wasn't Set.....") ;
       pea       @m68kde~1_63.L
       jsr       (A2)
       addq.w    #4,A7
BreakPointClear_6:
; BreakPointDisplay() ;
       jsr       _BreakPointDisplay
; return ;
BreakPointClear_4:
       movem.l   (A7)+,D2/A2
       unlk      A6
       rts
; }
; void WatchPointClear(void)
; {
_WatchPointClear:
       movem.l   D2/A2,-(A7)
       lea       _printf.L,A2
; unsigned int i ;
; WatchPointDisplay() ;
       jsr       _WatchPointDisplay
; printf("\r\nEnter Watch Point Number: ") ;
       pea       @m68kde~1_64.L
       jsr       (A2)
       addq.w    #4,A7
; i = xtod(_getch()) ;           // get watch pointer number
       move.l    D0,-(A7)
       jsr       __getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _xtod
       addq.w    #4,A7
       and.l     #255,D0
       move.l    D0,D2
; if((i < 0) || (i > 7))   {
       cmp.l     #0,D2
       blo.s     WatchPointClear_3
       cmp.l     #7,D2
       bls.s     WatchPointClear_1
WatchPointClear_3:
; printf("\r\nIllegal Range : Use 0 - 7") ;
       pea       @m68kde~1_61.L
       jsr       (A2)
       addq.w    #4,A7
; return ;
       bra       WatchPointClear_4
WatchPointClear_1:
; }
; if(WatchPointSetOrCleared[i] == 1)  {       // if watch point set
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointSetOrCleared.L,A0
       move.l    0(A0,D0.L),D0
       cmp.l     #1,D0
       bne.s     WatchPointClear_5
; WatchPointAddress[i] = 0 ;
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointAddress.L,A0
       clr.l     0(A0,D0.L)
; WatchPointSetOrCleared[i] = 0 ;
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointSetOrCleared.L,A0
       clr.l     0(A0,D0.L)
; printf("\r\nWatch Point Cleared.....\r\n") ;
       pea       @m68kde~1_65.L
       jsr       (A2)
       addq.w    #4,A7
       bra.s     WatchPointClear_6
WatchPointClear_5:
; }
; else
; printf("\r\nWatch Point Was not Set.....") ;
       pea       @m68kde~1_66.L
       jsr       (A2)
       addq.w    #4,A7
WatchPointClear_6:
; WatchPointDisplay() ;
       jsr       _WatchPointDisplay
; return ;
WatchPointClear_4:
       movem.l   (A7)+,D2/A2
       rts
; }
; void DisableBreakPoints(void)
; {
_DisableBreakPoints:
       link      A6,#-4
       move.l    D2,-(A7)
; int i ;
; volatile unsigned short int *ProgramBreakPointAddress ;
; for(i = 0; i < 8; i++)  {
       clr.l     D2
DisableBreakPoints_1:
       cmp.l     #8,D2
       bge       DisableBreakPoints_3
; if(BreakPointSetOrCleared[i] == 1)    {                                                    // if break point set
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointSetOrCleared.L,A0
       move.l    0(A0,D0.L),D0
       cmp.l     #1,D0
       bne.s     DisableBreakPoints_4
; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       move.l    0(A0,D0.L),-4(A6)
; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
       move.l    D2,D0
       lsl.l     #1,D0
       lea       _BreakPointInstruction.L,A0
       move.l    -4(A6),A1
       move.w    0(A0,D0.L),(A1)
DisableBreakPoints_4:
       addq.l    #1,D2
       bra       DisableBreakPoints_1
DisableBreakPoints_3:
       move.l    (A7)+,D2
       unlk      A6
       rts
; }
; }
; }
; void EnableBreakPoints(void)
; {
_EnableBreakPoints:
       link      A6,#-4
       move.l    D2,-(A7)
; int i ;
; volatile unsigned short int *ProgramBreakPointAddress ;
; for(i = 0; i < 8; i++)  {
       clr.l     D2
EnableBreakPoints_1:
       cmp.l     #8,D2
       bge.s     EnableBreakPoints_3
; if(BreakPointSetOrCleared[i] == 1)    {                                                     // if break point set
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointSetOrCleared.L,A0
       move.l    0(A0,D0.L),D0
       cmp.l     #1,D0
       bne.s     EnableBreakPoints_4
; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       move.l    0(A0,D0.L),-4(A6)
; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
       move.l    -4(A6),A0
       move.w    #20046,(A0)
EnableBreakPoints_4:
       addq.l    #1,D2
       bra       EnableBreakPoints_1
EnableBreakPoints_3:
       move.l    (A7)+,D2
       unlk      A6
       rts
; }
; }
; }
; void KillAllBreakPoints(void)
; {
_KillAllBreakPoints:
       link      A6,#-4
       move.l    D2,-(A7)
; int i ;
; volatile unsigned short int *ProgramBreakPointAddress ;
; for(i = 0; i < 8; i++)  {
       clr.l     D2
KillAllBreakPoints_1:
       cmp.l     #8,D2
       bge       KillAllBreakPoints_3
; // clear BP
; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       move.l    0(A0,D0.L),-4(A6)
; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
       move.l    D2,D0
       lsl.l     #1,D0
       lea       _BreakPointInstruction.L,A0
       move.l    -4(A6),A1
       move.w    0(A0,D0.L),(A1)
; BreakPointAddress[i] = 0 ;                                                             // set BP address to NULL
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       clr.l     0(A0,D0.L)
; BreakPointInstruction[i] = 0 ;
       move.l    D2,D0
       lsl.l     #1,D0
       lea       _BreakPointInstruction.L,A0
       clr.w     0(A0,D0.L)
; BreakPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointSetOrCleared.L,A0
       clr.l     0(A0,D0.L)
       addq.l    #1,D2
       bra       KillAllBreakPoints_1
KillAllBreakPoints_3:
       move.l    (A7)+,D2
       unlk      A6
       rts
; }
; //BreakPointDisplay() ;       // display the break points
; }
; void KillAllWatchPoints(void)
; {
_KillAllWatchPoints:
       move.l    D2,-(A7)
; int i ;
; for(i = 0; i < 8; i++)  {
       clr.l     D2
KillAllWatchPoints_1:
       cmp.l     #8,D2
       bge.s     KillAllWatchPoints_3
; WatchPointAddress[i] = 0 ;                                                             // set BP address to NULL
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointAddress.L,A0
       clr.l     0(A0,D0.L)
; WatchPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointSetOrCleared.L,A0
       clr.l     0(A0,D0.L)
       addq.l    #1,D2
       bra       KillAllWatchPoints_1
KillAllWatchPoints_3:
       move.l    (A7)+,D2
       rts
; }
; //WatchPointDisplay() ;       // display the break points
; }
; void SetBreakPoint(void)
; {
_SetBreakPoint:
       link      A6,#-4
       movem.l   D2/D3/D4/A2/A3,-(A7)
       lea       _printf.L,A2
       lea       _BreakPointSetOrCleared.L,A3
; int i ;
; int BPNumber;
; int BPAddress;
; volatile unsigned short int *ProgramBreakPointAddress ;
; // see if any free break points
; for(i = 0; i < 8; i ++) {
       clr.l     D2
SetBreakPoint_1:
       cmp.l     #8,D2
       bge.s     SetBreakPoint_3
; if( BreakPointSetOrCleared[i] == 0)
       move.l    D2,D0
       lsl.l     #2,D0
       move.l    0(A3,D0.L),D0
       bne.s     SetBreakPoint_4
; break ;         // if spare BP found allow user to set it
       bra.s     SetBreakPoint_3
SetBreakPoint_4:
       addq.l    #1,D2
       bra       SetBreakPoint_1
SetBreakPoint_3:
; }
; if(i == 8) {
       cmp.l     #8,D2
       bne.s     SetBreakPoint_6
; printf("\r\nNo FREE Break Points.....") ;
       pea       @m68kde~1_67.L
       jsr       (A2)
       addq.w    #4,A7
; return ;
       bra       SetBreakPoint_15
SetBreakPoint_6:
; }
; printf("\r\nBreak Point Address: ") ;
       pea       @m68kde~1_68.L
       jsr       (A2)
       addq.w    #4,A7
; BPAddress = Get8HexDigits(0) ;
       clr.l     -(A7)
       jsr       _Get8HexDigits
       addq.w    #4,A7
       move.l    D0,D3
; ProgramBreakPointAddress = (volatile unsigned short int *)(BPAddress) ;     // point to the instruction in the user program we are about to change
       move.l    D3,D4
; if((BPAddress & 0x00000001) == 0x00000001)  {   // cannot set BP at an odd address
       move.l    D3,D0
       and.l     #1,D0
       cmp.l     #1,D0
       bne.s     SetBreakPoint_9
; printf("\r\nError : Break Points CANNOT be set at ODD addresses") ;
       pea       @m68kde~1_69.L
       jsr       (A2)
       addq.w    #4,A7
; return ;
       bra       SetBreakPoint_15
SetBreakPoint_9:
; }
; if(BPAddress < 0x00008000)  {   // cannot set BP in ROM
       cmp.l     #32768,D3
       bhs.s     SetBreakPoint_11
; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]") ;
       pea       @m68kde~1_70.L
       jsr       (A2)
       addq.w    #4,A7
; return ;
       bra       SetBreakPoint_15
SetBreakPoint_11:
; }
; // search for first free bp or existing same BP
; for(i = 0; i < 8; i++)  {
       clr.l     D2
SetBreakPoint_13:
       cmp.l     #8,D2
       bge       SetBreakPoint_15
; if(BreakPointAddress[i] == BPAddress)   {
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       cmp.l     0(A0,D0.L),D3
       bne.s     SetBreakPoint_16
; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress) ;
       move.l    D3,-(A7)
       pea       @m68kde~1_71.L
       jsr       (A2)
       addq.w    #8,A7
; return ;
       bra       SetBreakPoint_15
SetBreakPoint_16:
; }
; if(BreakPointSetOrCleared[i] == 0) {
       move.l    D2,D0
       lsl.l     #2,D0
       move.l    0(A3,D0.L),D0
       bne       SetBreakPoint_18
; // set BP here
; BreakPointSetOrCleared[i] = 1 ;                                 // mark this breakpoint as set
       move.l    D2,D0
       lsl.l     #2,D0
       move.l    #1,0(A3,D0.L)
; BreakPointInstruction[i] = *ProgramBreakPointAddress ;          // copy the user program instruction here so we can put it back afterwards
       move.l    D4,A0
       move.l    D2,D0
       lsl.l     #1,D0
       lea       _BreakPointInstruction.L,A1
       move.w    (A0),0(A1,D0.L)
; printf("\r\nBreak Point Set at Address: [$%08x]", ProgramBreakPointAddress) ;
       move.l    D4,-(A7)
       pea       @m68kde~1_72.L
       jsr       (A2)
       addq.w    #8,A7
; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e)    ;   // put a Trap14 instruction at the user specified address
       move.l    D4,A0
       move.w    #20046,(A0)
; BreakPointAddress[i] = BPAddress ;                              // record the address of this break point in the debugger
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       move.l    D3,0(A0,D0.L)
; printf("\r\n") ;
       pea       @m68kde~1_6.L
       jsr       (A2)
       addq.w    #4,A7
; BreakPointDisplay() ;       // display the break points
       jsr       _BreakPointDisplay
; return ;
       bra.s     SetBreakPoint_15
SetBreakPoint_18:
       addq.l    #1,D2
       bra       SetBreakPoint_13
SetBreakPoint_15:
       movem.l   (A7)+,D2/D3/D4/A2/A3
       unlk      A6
       rts
; }
; }
; }
; void SetWatchPoint(void)
; {
_SetWatchPoint:
       link      A6,#-8
       movem.l   D2/D3/A2/A3,-(A7)
       lea       _printf.L,A2
       lea       _WatchPointSetOrCleared.L,A3
; int i ;
; int WPNumber;
; int WPAddress;
; volatile unsigned short int *ProgramWatchPointAddress ;
; // see if any free break points
; for(i = 0; i < 8; i ++) {
       clr.l     D2
SetWatchPoint_1:
       cmp.l     #8,D2
       bge.s     SetWatchPoint_3
; if( WatchPointSetOrCleared[i] == 0)
       move.l    D2,D0
       lsl.l     #2,D0
       move.l    0(A3,D0.L),D0
       bne.s     SetWatchPoint_4
; break ;         // if spare WP found allow user to set it
       bra.s     SetWatchPoint_3
SetWatchPoint_4:
       addq.l    #1,D2
       bra       SetWatchPoint_1
SetWatchPoint_3:
; }
; if(i == 8) {
       cmp.l     #8,D2
       bne.s     SetWatchPoint_6
; printf("\r\nNo FREE Watch Points.....") ;
       pea       @m68kde~1_73.L
       jsr       (A2)
       addq.w    #4,A7
; return ;
       bra       SetWatchPoint_11
SetWatchPoint_6:
; }
; printf("\r\nWatch Point Address: ") ;
       pea       @m68kde~1_74.L
       jsr       (A2)
       addq.w    #4,A7
; WPAddress = Get8HexDigits(0) ;
       clr.l     -(A7)
       jsr       _Get8HexDigits
       addq.w    #4,A7
       move.l    D0,D3
; // search for first free wp or existing same wp
; for(i = 0; i < 8; i++)  {
       clr.l     D2
SetWatchPoint_9:
       cmp.l     #8,D2
       bge       SetWatchPoint_11
; if(WatchPointAddress[i] == WPAddress && WPAddress != 0)   {     //so we can set a wp at 0
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointAddress.L,A0
       cmp.l     0(A0,D0.L),D3
       bne.s     SetWatchPoint_12
       tst.l     D3
       beq.s     SetWatchPoint_12
; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress) ;
       move.l    D3,-(A7)
       pea       @m68kde~1_75.L
       jsr       (A2)
       addq.w    #8,A7
; return ;
       bra       SetWatchPoint_11
SetWatchPoint_12:
; }
; if(WatchPointSetOrCleared[i] == 0) {
       move.l    D2,D0
       lsl.l     #2,D0
       move.l    0(A3,D0.L),D0
       bne       SetWatchPoint_14
; WatchPointSetOrCleared[i] = 1 ;                                 // mark this watchpoint as set
       move.l    D2,D0
       lsl.l     #2,D0
       move.l    #1,0(A3,D0.L)
; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress) ;
       move.l    D3,-(A7)
       pea       @m68kde~1_76.L
       jsr       (A2)
       addq.w    #8,A7
; WatchPointAddress[i] = WPAddress ;                              // record the address of this watch point in the debugger
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointAddress.L,A0
       move.l    D3,0(A0,D0.L)
; printf("\r\n") ;
       pea       @m68kde~1_6.L
       jsr       (A2)
       addq.w    #4,A7
; WatchPointDisplay() ;       // display the break points
       jsr       _WatchPointDisplay
; return ;
       bra.s     SetWatchPoint_11
SetWatchPoint_14:
       addq.l    #1,D2
       bra       SetWatchPoint_9
SetWatchPoint_11:
       movem.l   (A7)+,D2/D3/A2/A3
       unlk      A6
       rts
; }
; }
; }
; void HandleBreakPoint(void)
; {
_HandleBreakPoint:
       link      A6,#-4
       movem.l   A2/A3/A4,-(A7)
       lea       _i.L,A2
       lea       _printf.L,A3
       lea       _PC.L,A4
; volatile unsigned short int *ProgramBreakPointAddress ;
; // now we have to put the break point back to run the instruction
; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
; PC = PC - 2 ;  // ready for user to resume after reaching breakpoint
       subq.l    #2,(A4)
; printf("\r\n\r\n\r\n\r\n@BREAKPOINT") ;
       pea       @m68kde~1_77.L
       jsr       (A3)
       addq.w    #4,A7
; printf("\r\nSingle Step : [ON]") ;
       pea       @m68kde~1_78.L
       jsr       (A3)
       addq.w    #4,A7
; printf("\r\nBreakPoints : [Enabled]") ;
       pea       @m68kde~1_79.L
       jsr       (A3)
       addq.w    #4,A7
; // now clear the break point (put original instruction back)
; ProgramBreakPointAddress = PC ;
       move.l    (A4),-4(A6)
; for(i = 0; i < 8; i ++) {
       clr.l     (A2)
HandleBreakPoint_1:
       move.l    (A2),D0
       cmp.l     #8,D0
       bhs       HandleBreakPoint_3
; if(BreakPointAddress[i] == PC) {        // if we have found the breakpoint
       move.l    (A2),D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       move.l    0(A0,D0.L),D1
       cmp.l     (A4),D1
       bne       HandleBreakPoint_4
; BreakPointAddress[i] = 0 ;
       move.l    (A2),D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       clr.l     0(A0,D0.L)
; BreakPointSetOrCleared[i] = 0 ;
       move.l    (A2),D0
       lsl.l     #2,D0
       lea       _BreakPointSetOrCleared.L,A0
       clr.l     0(A0,D0.L)
; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
       move.l    (A2),D0
       lsl.l     #1,D0
       lea       _BreakPointInstruction.L,A0
       move.l    -4(A6),A1
       move.w    0(A0,D0.L),(A1)
; BreakPointInstruction[i] = 0 ;
       move.l    (A2),D0
       lsl.l     #1,D0
       lea       _BreakPointInstruction.L,A0
       clr.w     0(A0,D0.L)
HandleBreakPoint_4:
       addq.l    #1,(A2)
       bra       HandleBreakPoint_1
HandleBreakPoint_3:
; }
; }
; DumpRegisters() ;
       jsr       _DumpRegisters
; printf("\r\nPress <SPACE> to Execute Next Instruction");
       pea       @m68kde~1_41.L
       jsr       (A3)
       addq.w    #4,A7
; printf("\r\nPress <ESC> to Resume User Program\r\n") ;
       pea       @m68kde~1_80.L
       jsr       (A3)
       addq.w    #4,A7
; menu() ;
       jsr       _menu
       movem.l   (A7)+,A2/A3/A4
       unlk      A6
       rts
; }
; void UnknownCommand()
; {
_UnknownCommand:
; printf("\r\nUnknown Command.....\r\n") ;
       pea       @m68kde~1_81.L
       jsr       _printf
       addq.w    #4,A7
; Help() ;
       jsr       _Help
       rts
; }
; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
; void CallDebugMonitor(void)
; {
_CallDebugMonitor:
; printf("\r\nProgram Ended (TRAP #15)....") ;
       pea       @m68kde~1_82.L
       jsr       _printf
       addq.w    #4,A7
; menu();
       jsr       _menu
       rts
; }
; void Breakpoint(void)
; {
_Breakpoint:
       move.l    D2,-(A7)
; char c;
; c = toupper(_getch());
       move.l    D0,-(A7)
       jsr       __getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _toupper
       addq.w    #4,A7
       move.b    D0,D2
; if( c == (char)('D'))                                      // BreakPoint Display
       cmp.b     #68,D2
       bne.s     Breakpoint_1
; BreakPointDisplay() ;
       jsr       _BreakPointDisplay
       bra       Breakpoint_10
Breakpoint_1:
; else if(c == (char)('K')) {                                 // breakpoint Kill
       cmp.b     #75,D2
       bne.s     Breakpoint_3
; printf("\r\nKill All Break Points...(y/n)?") ;
       pea       @m68kde~1_83.L
       jsr       _printf
       addq.w    #4,A7
; c = toupper(_getch());
       move.l    D0,-(A7)
       jsr       __getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _toupper
       addq.w    #4,A7
       move.b    D0,D2
; if(c == (char)('Y'))
       cmp.b     #89,D2
       bne.s     Breakpoint_5
; KillAllBreakPoints() ;
       jsr       _KillAllBreakPoints
Breakpoint_5:
       bra.s     Breakpoint_10
Breakpoint_3:
; }
; else if(c == (char)('S')) {
       cmp.b     #83,D2
       bne.s     Breakpoint_7
; SetBreakPoint() ;
       jsr       _SetBreakPoint
       bra.s     Breakpoint_10
Breakpoint_7:
; }
; else if(c == (char)('C')) {
       cmp.b     #67,D2
       bne.s     Breakpoint_9
; BreakPointClear() ;
       jsr       _BreakPointClear
       bra.s     Breakpoint_10
Breakpoint_9:
; }
; else
; UnknownCommand() ;
       jsr       _UnknownCommand
Breakpoint_10:
       move.l    (A7)+,D2
       rts
; }
; void Watchpoint(void)
; {
_Watchpoint:
       move.l    D2,-(A7)
; char c;
; c = toupper(_getch());
       move.l    D0,-(A7)
       jsr       __getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _toupper
       addq.w    #4,A7
       move.b    D0,D2
; if( c == (char)('D'))                                      // WatchPoint Display
       cmp.b     #68,D2
       bne.s     Watchpoint_1
; WatchPointDisplay() ;
       jsr       _WatchPointDisplay
       bra       Watchpoint_10
Watchpoint_1:
; else if(c == (char)('K')) {                                 // wtahcpoint Kill
       cmp.b     #75,D2
       bne.s     Watchpoint_3
; printf("\r\nKill All Watch Points...(y/n)?") ;
       pea       @m68kde~1_84.L
       jsr       _printf
       addq.w    #4,A7
; c = toupper(_getch());
       move.l    D0,-(A7)
       jsr       __getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _toupper
       addq.w    #4,A7
       move.b    D0,D2
; if(c == (char)('Y'))
       cmp.b     #89,D2
       bne.s     Watchpoint_5
; KillAllWatchPoints() ;
       jsr       _KillAllWatchPoints
Watchpoint_5:
       bra.s     Watchpoint_10
Watchpoint_3:
; }
; else if(c == (char)('S')) {
       cmp.b     #83,D2
       bne.s     Watchpoint_7
; SetWatchPoint() ;
       jsr       _SetWatchPoint
       bra.s     Watchpoint_10
Watchpoint_7:
; }
; else if(c == (char)('C')) {
       cmp.b     #67,D2
       bne.s     Watchpoint_9
; WatchPointClear() ;
       jsr       _WatchPointClear
       bra.s     Watchpoint_10
Watchpoint_9:
; }
; else
; UnknownCommand() ;
       jsr       _UnknownCommand
Watchpoint_10:
       move.l    (A7)+,D2
       rts
; }
; void Help(void)
; {
_Help:
       movem.l   D2/A2,-(A7)
       lea       _printf.L,A2
; char *banner = "\r\n----------------------------------------------------------------" ;
       lea       @m68kde~1_85.L,A0
       move.l    A0,D2
; printf(banner) ;
       move.l    D2,-(A7)
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\n  Final Project") ;
       pea       @m68kde~1_86.L
       jsr       (A2)
       addq.w    #4,A7
; printf(banner) ;
       move.l    D2,-(A7)
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\n  H    - Say Hello World") ;
       pea       @m68kde~1_87.L
       jsr       (A2)
       addq.w    #4,A7
; printf(banner) ;
       move.l    D2,-(A7)
       jsr       (A2)
       addq.w    #4,A7
; printf("\r\n  T    - Run Tetris Game") ;
       pea       @m68kde~1_88.L
       jsr       (A2)
       addq.w    #4,A7
; printf(banner) ;
       move.l    D2,-(A7)
       jsr       (A2)
       addq.w    #4,A7
       movem.l   (A7)+,D2/A2
       rts
; }
; void writeVGA_debug(int addr, char data, char z) {
_writeVGA_debug:
       link      A6,#0
       move.l    D2,-(A7)
; char *VGA = (char *)(VGA_ADDRESS + addr * 2);
       move.l    #-65536,D0
       move.l    8(A6),-(A7)
       pea       2
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       add.l     D1,D0
       move.l    D0,D2
; *(char *)(0xFF030000) = (0xF2 & 0xF8) | z;
       move.w    #240,D0
       move.b    19(A6),D1
       ext.w     D1
       or.w      D1,D0
       move.b    D0,-16580608
; *(VGA) = data;
       move.l    D2,A0
       move.b    15(A6),(A0)
; *(VGA + 1) = data;
       move.l    D2,A0
       move.b    15(A6),1(A0)
       move.l    (A7)+,D2
       unlk      A6
       rts
; }
; void menu(void)
; {
_menu:
       link      A6,#-12
       movem.l   D2/D3/D4/D5/A2,-(A7)
       lea       _printf.L,A2
; char c, data, z;
; int c1 ;
; int addr, i, j;
; while(1)    {
menu_1:
; FlushKeyboard() ;               // dump unread characters from keyboard
       jsr       _FlushKeyboard
; printf("\r\n#") ;
       pea       @m68kde~1_89.L
       jsr       (A2)
       addq.w    #4,A7
; c = toupper(_getch());
       move.l    D0,-(A7)
       jsr       __getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _toupper
       addq.w    #4,A7
       move.b    D0,D5
; if ( c == (char)('T'))  {
       cmp.b     #84,D5
       bne.s     menu_4
; printf("\nRunning Tetris Game\n");
       pea       @m68kde~1_90.L
       jsr       (A2)
       addq.w    #4,A7
; tetris_main();
       jsr       _tetris_main
; continue;
       bra       menu_2
menu_4:
; }
; if ( c == (char)('H'))  {
       cmp.b     #72,D5
       bne.s     menu_6
; printf("\nSaying Hello World\n");
       pea       @m68kde~1_91.L
       jsr       (A2)
       addq.w    #4,A7
; say_hello();
       jsr       _say_hello
; say_world();
       jsr       _say_world
; continue;
       bra       menu_2
menu_6:
; }
; if ( c == (char)('V'))  {
       cmp.b     #86,D5
       bne       menu_8
; printf("\nMemory Change in VGA\n");
       pea       @m68kde~1_92.L
       jsr       (A2)
       addq.w    #4,A7
; // while (1) {
; //     printf("\nAddress: 0x0000 to 0x0FFF");
; //     addr = Get4HexDigits(0);
; //     printf("\nData: ");
; //     data = Get2HexDigits(0);
; //     writeVGA(addr, data);
; // }
; j = 0;
       clr.l     D2
; z = 0;
       clr.b     D4
; // 80
; // 40
; for (i = 0; i <= 0xFFFF; i++) {
       clr.l     D3
menu_10:
       cmp.l     #65535,D3
       bhi       menu_12
; data = (j + 'A');
       move.l    D2,D0
       add.l     #65,D0
       move.b    D0,-9(A6)
; writeVGA_debug(i, data, z);
       ext.w     D4
       ext.l     D4
       move.l    D4,-(A7)
       move.b    -9(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    D3,-(A7)
       jsr       _writeVGA_debug
       add.w     #12,A7
; ++j; ++z;
       addq.l    #1,D2
       addq.b    #1,D4
; if (z == 8) z = 1;
       cmp.b     #8,D4
       bne.s     menu_13
       moveq     #1,D4
menu_13:
; if (j == 26) j = 0;
       cmp.l     #26,D2
       bne.s     menu_15
       clr.l     D2
menu_15:
; printf("\nAddress: 0x%04X, Data: %c", i, j + 'A');
       move.l    D2,D1
       add.l     #65,D1
       move.l    D1,-(A7)
       move.l    D3,-(A7)
       pea       @m68kde~1_93.L
       jsr       (A2)
       add.w     #12,A7
; Wait1ms();
       jsr       _Wait1ms
       addq.l    #1,D3
       bra       menu_10
menu_12:
; }
; continue;
       bra.s     menu_2
menu_8:
; }
; // if ( c == (char)('M'))  {
; //     while (1){
; //         *(char *)(VGA_ADDRESS) = 0x41;
; //         printf("\nAddress: %ld", VGA_ADDRESS);
; //     }
; //     continue;
; // }
; // if ( c == (char)('S'))  {
; //     printf("\nSasha\n");
; //     say_Sasha();
; //     cursor_x = cx;
; //     cursor_y = cy;
; //     while (1) {
; //         FlushKeyboard() ;               // dump unread characters from keyboard
; //         printf("\r\n#") ;
; //         c = toupper(_getch());
; //         if (c == (char)('W')) {
; //             cy -= 1;
; //             printf("\nMove Up, cy = %d\n", cy);
; //             cursor_y = cy;
; //             continue;
; //         }
; //         if (c == (char)('S')) {
; //             cy += 1;
; //             printf("\nMove Down, cy = %d\n", cy);
; //             cursor_y = cy;
; //             continue;
; //         }
; //         if (c == (char)('A')) {
; //             cx -= 1;
; //             printf("\nMove Left, cx = %d\n", cx);
; //             cursor_x = cx;
; //             continue;
; //         }
; //         if (c == (char)('D')) {
; //             cx += 1;
; //             printf("\nMove Right, cx = %d\n", cx);
; //             cursor_x = cx;
; //             continue;
; //         }
; //     }
; //     continue;
; // }
; UnknownCommand() ;
       jsr       _UnknownCommand
menu_2:
       bra       menu_1
; }
; }
; void PrintErrorMessageandAbort(char *string) {
_PrintErrorMessageandAbort:
       link      A6,#0
; printf("\r\n\r\nProgram ABORT !!!!!!\r\n") ;
       pea       @m68kde~1_94.L
       jsr       _printf
       addq.w    #4,A7
; printf("%s\r\n", string) ;
       move.l    8(A6),-(A7)
       pea       @m68kde~1_95.L
       jsr       _printf
       addq.w    #8,A7
; menu() ;
       jsr       _menu
       unlk      A6
       rts
; }
; void IRQMessage(int level) {
_IRQMessage:
       link      A6,#0
; printf("\r\n\r\nProgram ABORT !!!!!");
       pea       @m68kde~1_96.L
       jsr       _printf
       addq.w    #4,A7
; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level) ;
       move.l    8(A6),-(A7)
       pea       @m68kde~1_97.L
       jsr       _printf
       addq.w    #8,A7
; menu() ;
       jsr       _menu
       unlk      A6
       rts
; }
; void UnhandledIRQ1(void) {
_UnhandledIRQ1:
; IRQMessage(1);
       pea       1
       jsr       _IRQMessage
       addq.w    #4,A7
       rts
; }
; void UnhandledIRQ2(void) {
_UnhandledIRQ2:
; IRQMessage(2);
       pea       2
       jsr       _IRQMessage
       addq.w    #4,A7
       rts
; }
; void UnhandledIRQ3(void){
_UnhandledIRQ3:
; IRQMessage(3);
       pea       3
       jsr       _IRQMessage
       addq.w    #4,A7
       rts
; }
; void UnhandledIRQ4(void) {
_UnhandledIRQ4:
; IRQMessage(4);
       pea       4
       jsr       _IRQMessage
       addq.w    #4,A7
       rts
; }
; void UnhandledIRQ5(void) {
_UnhandledIRQ5:
; IRQMessage(5);
       pea       5
       jsr       _IRQMessage
       addq.w    #4,A7
       rts
; }
; void UnhandledIRQ6(void) {
_UnhandledIRQ6:
; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....") ;
       pea       @m68kde~1_98.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
; menu() ;
       jsr       _menu
       rts
; }
; void UnhandledIRQ7(void) {
_UnhandledIRQ7:
; IRQMessage(7);
       pea       7
       jsr       _IRQMessage
       addq.w    #4,A7
       rts
; }
; void UnhandledTrap(void) {
_UnhandledTrap:
; PrintErrorMessageandAbort("Unhandled Trap !!!!!") ;
       pea       @m68kde~1_99.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
       rts
; }
; void BusError() {
_BusError:
; PrintErrorMessageandAbort("BUS Error!") ;
       pea       @m68kde~1_100.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
       rts
; }
; void AddressError() {
_AddressError:
; PrintErrorMessageandAbort("ADDRESS Error!") ;
       pea       @m68kde~1_101.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
       rts
; }
; void IllegalInstruction() {
_IllegalInstruction:
; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION") ;
       pea       @m68kde~1_102.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
       rts
; }
; void Dividebyzero() {
_Dividebyzero:
; PrintErrorMessageandAbort("DIVIDE BY ZERO") ;
       pea       @m68kde~1_103.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
       rts
; }
; void Check() {
_Check:
; PrintErrorMessageandAbort("'CHK' INSTRUCTION") ;
       pea       @m68kde~1_104.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
       rts
; }
; void Trapv() {
_Trapv:
; PrintErrorMessageandAbort("TRAPV INSTRUCTION") ;
       pea       @m68kde~1_105.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
       rts
; }
; void PrivError() {
_PrivError:
; PrintErrorMessageandAbort("PRIVILEGE VIOLATION") ;
       pea       @m68kde~1_106.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
       rts
; }
; void UnitIRQ() {
_UnitIRQ:
; PrintErrorMessageandAbort("UNINITIALISED IRQ") ;
       pea       @m68kde~1_107.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
       rts
; }
; void Spurious() {
_Spurious:
; PrintErrorMessageandAbort("SPURIOUS IRQ") ;
       pea       @m68kde~1_108.L
       jsr       _PrintErrorMessageandAbort
       addq.w    #4,A7
       rts
; }
; void main(void)
; {
_main:
       link      A6,#-16
       movem.l   D2/A2,-(A7)
       lea       _InstallExceptionHandler.L,A2
; char c ;
; int i, j ;
; char *BugMessage = "CPEN 412 2023W2\r\nTom Wang, 76340348";
       lea       @m68kde~1_109.L,A0
       move.l    A0,-8(A6)
; char *CopyrightMessage = "Copyright (C) PJ Davies 2016";
       lea       @m68kde~1_110.L,A0
       move.l    A0,-4(A6)
; KillAllBreakPoints() ;
       jsr       _KillAllBreakPoints
; i = x = y = z = PortA_Count = 0;
       clr.l     _PortA_Count.L
       clr.l     _z.L
       clr.l     _y.L
       clr.l     _x.L
       clr.l     D2
; Trace = GoFlag = 0;                       // used in tracing/single stepping
       clr.l     _GoFlag.L
       clr.l     _Trace.L
; Echo = 1 ;
       move.l    #1,_Echo.L
; // Initialise Breakpoint variables
; for(i = 0; i < 8; i++)  {
       clr.l     D2
main_1:
       cmp.l     #8,D2
       bge       main_3
; BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointAddress.L,A0
       clr.l     0(A0,D0.L)
; WatchPointAddress[i] = 0 ;
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointAddress.L,A0
       clr.l     0(A0,D0.L)
; BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
       move.l    D2,D0
       lsl.l     #1,D0
       lea       _BreakPointInstruction.L,A0
       clr.w     0(A0,D0.L)
; BreakPointSetOrCleared[i] = 0;          // indicates if break point set
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _BreakPointSetOrCleared.L,A0
       clr.l     0(A0,D0.L)
; WatchPointSetOrCleared[i] = 0;
       move.l    D2,D0
       lsl.l     #2,D0
       lea       _WatchPointSetOrCleared.L,A0
       clr.l     0(A0,D0.L)
       addq.l    #1,D2
       bra       main_1
main_3:
; }
; Init_RS232() ;     // initialise the RS232 port
       jsr       _Init_RS232
; for( i = 32; i < 48; i++)
       moveq     #32,D2
main_4:
       cmp.l     #48,D2
       bge.s     main_6
; InstallExceptionHandler(UnhandledTrap, i) ;		        // install Trap exception handler on vector 32-47
       move.l    D2,-(A7)
       pea       _UnhandledTrap.L
       jsr       (A2)
       addq.w    #8,A7
       addq.l    #1,D2
       bra       main_4
main_6:
; InstallExceptionHandler(menu, 47) ;		                   // TRAP #15 call debug and end program
       pea       47
       pea       _menu.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(UnhandledIRQ1, 25) ;		      // install handler for interrupts
       pea       25
       pea       _UnhandledIRQ1.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(UnhandledIRQ2, 26) ;		      // install handler for interrupts
       pea       26
       pea       _UnhandledIRQ2.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(UnhandledIRQ3, 27) ;		      // install handler for interrupts
       pea       27
       pea       _UnhandledIRQ3.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(UnhandledIRQ4, 28) ;		      // install handler for interrupts
       pea       28
       pea       _UnhandledIRQ4.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(UnhandledIRQ5, 29) ;		      // install handler for interrupts
       pea       29
       pea       _UnhandledIRQ5.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(UnhandledIRQ6, 30) ;		      // install handler for interrupts
       pea       30
       pea       _UnhandledIRQ6.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(UnhandledIRQ7, 31) ;		      // install handler for interrupts
       pea       31
       pea       _UnhandledIRQ7.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(HandleBreakPoint, 46) ;		           // install Trap 14 Break Point exception handler on vector 46
       pea       46
       pea       _HandleBreakPoint.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(DumpRegistersandPause, 29) ;		   // install TRACE handler for IRQ5 on vector 29
       pea       29
       pea       _DumpRegistersandPause.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(BusError,2) ;                          // install Bus error handler
       pea       2
       pea       _BusError.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(AddressError,3) ;                      // install address error handler (doesn't work on soft core 68k implementation)
       pea       3
       pea       _AddressError.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(IllegalInstruction,4) ;                // install illegal instruction exception handler
       pea       4
       pea       _IllegalInstruction.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(Dividebyzero,5) ;                      // install /0 exception handler
       pea       5
       pea       _Dividebyzero.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(Check,6) ;                             // install check instruction exception handler
       pea       6
       pea       _Check.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(Trapv,7) ;                             // install trapv instruction exception handler
       pea       7
       pea       _Trapv.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(PrivError,8) ;                         // install Priv Violation exception handler
       pea       8
       pea       _PrivError.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(UnitIRQ,15) ;                          // install uninitialised IRQ exception handler
       pea       15
       pea       _UnitIRQ.L
       jsr       (A2)
       addq.w    #8,A7
; InstallExceptionHandler(Check,24) ;                            // install spurious IRQ exception handler
       pea       24
       pea       _Check.L
       jsr       (A2)
       addq.w    #8,A7
; FlushKeyboard() ;                        // dump unread characters from keyboard
       jsr       _FlushKeyboard
; TraceException = 0 ;                     // clear trace exception port to remove any software generated single step/trace
       clr.b     4194314
; printf("\r\n%s", BugMessage) ;
       move.l    -8(A6),-(A7)
       pea       @m68kde~1_111.L
       jsr       _printf
       addq.w    #8,A7
; printf("\r\n%s", CopyrightMessage) ;
       move.l    -4(A6),-(A7)
       pea       @m68kde~1_111.L
       jsr       _printf
       addq.w    #8,A7
; // update_cursor(40, 20);
; // octlAddress = 0xF2;
; // octlAddress1 = 0xF2;
; // changeChar(20 * 80 + 39, ' ');
; menu();
       jsr       _menu
       movem.l   (A7)+,D2/A2
       unlk      A6
       rts
; }
; C:\USERS\10054\ONEDRIVE\CPEN 412 FINAL PROJECT\FINAL_PROJECT_2023_SEM2_STUDENT_TEMPLATE\FINAL_PROJECT_2023_SEM2_STUDENT_TEMPLATE\PROGRAMS\DEBUGMONITORCODE\SAY_PHONEME.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
; #include "say_phoneme.h"
; void talkphonemeAA (){ say_phoneme(phoneme_AA  ) ; };
_talkphonemeAA:
       pea       24
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeAE (){ say_phoneme(phoneme_AE  ) ; };
_talkphonemeAE:
       pea       26
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeAO (){ say_phoneme(phoneme_AO  ) ; };
_talkphonemeAO:
       pea       23
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeAR (){ say_phoneme(phoneme_AR  ) ; };
_talkphonemeAR:
       pea       59
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeAW (){ say_phoneme(phoneme_AW  ) ; };
_talkphonemeAW:
       pea       32
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeAX (){ say_phoneme(phoneme_AX  ) ; };
_talkphonemeAX:
       pea       15
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeAY (){ say_phoneme(phoneme_AY  ) ; };
_talkphonemeAY:
       pea       6
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeBB1(){ say_phoneme(phoneme_BB1 ) ; };
_talkphonemeBB1:
       pea       28
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeBB2(){ say_phoneme(phoneme_BB2 ) ; };
_talkphonemeBB2:
       pea       63
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeCH (){ say_phoneme(phoneme_CH  ) ; };
_talkphonemeCH:
       pea       50
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeDD1(){ say_phoneme(phoneme_DD1 ) ; };
_talkphonemeDD1:
       pea       21
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeDD2(){ say_phoneme(phoneme_DD2 ) ; };
_talkphonemeDD2:
       pea       33
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeDH1(){ say_phoneme(phoneme_DH1 ) ; };
_talkphonemeDH1:
       pea       18
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeDH2(){ say_phoneme(phoneme_DH2 ) ; };
_talkphonemeDH2:
       pea       54
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeEH (){ say_phoneme(phoneme_EH  ) ; };
_talkphonemeEH:
       pea       7
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeEL (){ say_phoneme(phoneme_EL  ) ; };
_talkphonemeEL:
       pea       62
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeER1(){ say_phoneme(phoneme_ER1 ) ; };
_talkphonemeER1:
       pea       51
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeER2(){ say_phoneme(phoneme_ER2 ) ; };
_talkphonemeER2:
       pea       52
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeEY (){ say_phoneme(phoneme_EY  ) ; };
_talkphonemeEY:
       pea       20
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeFF (){ say_phoneme(phoneme_FF  ) ; };
_talkphonemeFF:
       pea       40
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeGG1(){ say_phoneme(phoneme_GG1 ) ; };
_talkphonemeGG1:
       pea       36
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeGG2(){ say_phoneme(phoneme_GG2 ) ; };
_talkphonemeGG2:
       pea       61
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeGG3(){ say_phoneme(phoneme_GG3 ) ; };
_talkphonemeGG3:
       pea       34
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeHH1(){ say_phoneme(phoneme_HH1 ) ; };
_talkphonemeHH1:
       pea       27
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeHH2(){ say_phoneme(phoneme_HH2 ) ; };
_talkphonemeHH2:
       pea       57
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeIH (){ say_phoneme(phoneme_IH  ) ; };
_talkphonemeIH:
       pea       12
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeIY (){ say_phoneme(phoneme_IY  ) ; };
_talkphonemeIY:
       pea       19
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeJH (){ say_phoneme(phoneme_JH  ) ; };
_talkphonemeJH:
       pea       10
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeKK1(){ say_phoneme(phoneme_KK1 ) ; };
_talkphonemeKK1:
       pea       42
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeKK2(){ say_phoneme(phoneme_KK2 ) ; };
_talkphonemeKK2:
       pea       41
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeKK3(){ say_phoneme(phoneme_KK3 ) ; };
_talkphonemeKK3:
       pea       8
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeLL (){ say_phoneme(phoneme_LL  ) ; };
_talkphonemeLL:
       pea       45
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeMM (){ say_phoneme(phoneme_MM  ) ; };
_talkphonemeMM:
       pea       16
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeNG (){ say_phoneme(phoneme_NG  ) ; };
_talkphonemeNG:
       pea       44
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeNN1(){ say_phoneme(phoneme_NN1 ) ; };
_talkphonemeNN1:
       pea       11
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeNN2(){ say_phoneme(phoneme_NN2 ) ; };
_talkphonemeNN2:
       pea       56
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeOR (){ say_phoneme(phoneme_OR  ) ; };
_talkphonemeOR:
       pea       58
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeOW (){ say_phoneme(phoneme_OW  ) ; };
_talkphonemeOW:
       pea       53
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeOY (){ say_phoneme(phoneme_OY  ) ; };
_talkphonemeOY:
       pea       5
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemePP (){ say_phoneme(phoneme_PP  ) ; };
_talkphonemePP:
       pea       9
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeRR1(){ say_phoneme(phoneme_RR1 ) ; };
_talkphonemeRR1:
       pea       14
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeRR2(){ say_phoneme(phoneme_RR2 ) ; };
_talkphonemeRR2:
       pea       39
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeSH (){ say_phoneme(phoneme_SH  ) ; };
_talkphonemeSH:
       pea       37
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeSS (){ say_phoneme(phoneme_SS  ) ; };
_talkphonemeSS:
       pea       55
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeTH (){ say_phoneme(phoneme_TH  ) ; };
_talkphonemeTH:
       pea       29
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeTT1(){ say_phoneme(phoneme_TT1 ) ; };
_talkphonemeTT1:
       pea       17
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeTT2(){ say_phoneme(phoneme_TT2 ) ; };
_talkphonemeTT2:
       pea       13
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeUH (){ say_phoneme(phoneme_UH  ) ; };
_talkphonemeUH:
       pea       30
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeUW1(){ say_phoneme(phoneme_UW1 ) ; };
_talkphonemeUW1:
       pea       22
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeUW2(){ say_phoneme(phoneme_UW2 ) ; };
_talkphonemeUW2:
       pea       31
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeVV (){ say_phoneme(phoneme_VV  ) ; };
_talkphonemeVV:
       pea       35
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeWH (){ say_phoneme(phoneme_WH  ) ; };
_talkphonemeWH:
       pea       48
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeWW (){ say_phoneme(phoneme_WW  ) ; };
_talkphonemeWW:
       pea       46
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeXR (){ say_phoneme(phoneme_XR  ) ; };
_talkphonemeXR:
       pea       47
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeYR (){ say_phoneme(phoneme_YR  ) ; };
_talkphonemeYR:
       pea       60
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeYY1(){ say_phoneme(phoneme_YY1 ) ; };
_talkphonemeYY1:
       pea       49
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeYY2(){ say_phoneme(phoneme_YY2 ) ; };
_talkphonemeYY2:
       pea       25
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeZH (){ say_phoneme(phoneme_ZH  ) ; };
_talkphonemeZH:
       pea       38
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemeZZ (){ say_phoneme(phoneme_ZZ  ) ; };
_talkphonemeZZ:
       pea       43
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemePA1(){ say_phoneme(phoneme_PA1 ) ; };
_talkphonemePA1:
       clr.l     -(A7)
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemePA2(){ say_phoneme(phoneme_PA2 ) ; };
_talkphonemePA2:
       pea       1
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemePA3(){ say_phoneme(phoneme_PA3 ) ; };
_talkphonemePA3:
       pea       2
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemePA4(){ say_phoneme(phoneme_PA4 ) ; };
_talkphonemePA4:
       pea       3
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkphonemePA5(){ say_phoneme(phoneme_PA5 ) ; };
_talkphonemePA5:
       pea       4
       jsr       _say_phoneme
       addq.w    #4,A7
       rts
; void talkword0() {
_talkword0:
; talkphonemeZZ  ()   ;
       jsr       _talkphonemeZZ
; talkphonemeEH  ()   ;
       jsr       _talkphonemeEH
; talkphonemeRR2 ()   ;
       jsr       _talkphonemeRR2
; talkphonemeOW  ()   ;
       jsr       _talkphonemeOW
       rts
; }
; void talkword1() {
_talkword1:
; talkphonemeWW    ()  ;
       jsr       _talkphonemeWW
; talkphonemeAO    ()  ;
       jsr       _talkphonemeAO
; talkphonemeNN1   ()  ;
       jsr       _talkphonemeNN1
       rts
; }
; void talkword2() {
_talkword2:
; talkphonemeTT2();
       jsr       _talkphonemeTT2
; talkphonemeUW2();
       jsr       _talkphonemeUW2
       rts
; }
; void talkword3() {
_talkword3:
; talkphonemeTH ();
       jsr       _talkphonemeTH
; talkphonemeRR2();
       jsr       _talkphonemeRR2
; talkphonemeIY ();
       jsr       _talkphonemeIY
       rts
; }
; void talkword4() {
_talkword4:
; talkphonemeFF  ();
       jsr       _talkphonemeFF
; talkphonemeOR  ();
       jsr       _talkphonemeOR
       rts
; }
; void talkword5() {
_talkword5:
; talkphonemeFF();
       jsr       _talkphonemeFF
; talkphonemeAY();
       jsr       _talkphonemeAY
; talkphonemeVV();
       jsr       _talkphonemeVV
       rts
; }
; void talkword6() {
_talkword6:
       move.l    A2,-(A7)
       lea       _talkphonemeSS.L,A2
; talkphonemeSS  ();
       jsr       (A2)
; talkphonemeIH  ();
       jsr       _talkphonemeIH
; talkphonemeKK2 ();
       jsr       _talkphonemeKK2
; talkphonemeSS  ();
       jsr       (A2)
; talkphonemeSS  ();
       jsr       (A2)
       move.l    (A7)+,A2
       rts
; }
; void talkword7() {
_talkword7:
; talkphonemeSS    ();
       jsr       _talkphonemeSS
; talkphonemeEH    ();
       jsr       _talkphonemeEH
; talkphonemeVV    ();
       jsr       _talkphonemeVV
; talkphonemeAX    ();
       jsr       _talkphonemeAX
; talkphonemeNN1   ();
       jsr       _talkphonemeNN1
       rts
; }
; void talkword8() {
_talkword8:
; talkphonemeEY  ();
       jsr       _talkphonemeEY
; talkphonemeTT1 ();
       jsr       _talkphonemeTT1
       rts
; }
; void talkword9() {
_talkword9:
; talkphonemeNN2();
       jsr       _talkphonemeNN2
; talkphonemeAY ();
       jsr       _talkphonemeAY
; talkphonemeNN1();
       jsr       _talkphonemeNN1
       rts
; }
; void talkword10() {
_talkword10:
; talkphonemeTT2 ();
       jsr       _talkphonemeTT2
; talkphonemeEH  ();
       jsr       _talkphonemeEH
; talkphonemeNN1 ();
       jsr       _talkphonemeNN1
       rts
; }
; void talkword11() {
_talkword11:
; talkphonemeIH ();
       jsr       _talkphonemeIH
; talkphonemeLL ();
       jsr       _talkphonemeLL
; talkphonemeEH ();
       jsr       _talkphonemeEH
; talkphonemeVV ();
       jsr       _talkphonemeVV
; talkphonemeEH ();
       jsr       _talkphonemeEH
; talkphonemeNN1();
       jsr       _talkphonemeNN1
       rts
; }
; void talkword12() {
_talkword12:
; talkphonemeTT2 ();
       jsr       _talkphonemeTT2
; talkphonemeWW  ();
       jsr       _talkphonemeWW
; talkphonemeEH  ();
       jsr       _talkphonemeEH
; talkphonemeEL  ();
       jsr       _talkphonemeEL
; talkphonemeVV  ();
       jsr       _talkphonemeVV
       rts
; }
; void talkword13() {
_talkword13:
; talkphonemeTH  ();
       jsr       _talkphonemeTH
; talkphonemeER2 ();
       jsr       _talkphonemeER2
       rts
; }
; void talkwordteen() {
_talkwordteen:
; talkphonemeTT2   ();
       jsr       _talkphonemeTT2
; talkphonemeIY    ();
       jsr       _talkphonemeIY
; talkphonemeNN1   ();
       jsr       _talkphonemeNN1
       rts
; }
; void talkword14() {
_talkword14:
; talkword4();
       jsr       _talkword4
; talkwordteen();
       jsr       _talkwordteen
       rts
; }
; void talkword15() {
_talkword15:
; talkphonemeFF ();
       jsr       _talkphonemeFF
; talkphonemeIH ();
       jsr       _talkphonemeIH
; talkphonemeFF ();
       jsr       _talkphonemeFF
; talkwordteen  ();
       jsr       _talkwordteen
       rts
; }
; void talkword16() {
_talkword16:
; talkword6    ();
       jsr       _talkword6
; talkwordteen ();
       jsr       _talkwordteen
       rts
; }
; void talkword17() {
_talkword17:
; talkword7      ();
       jsr       _talkword7
; talkwordteen   ();
       jsr       _talkwordteen
       rts
; }
; void talkword18() {
_talkword18:
; talkword8    ();
       jsr       _talkword8
; talkwordteen ();
       jsr       _talkwordteen
       rts
; }
; void talkword19() {
_talkword19:
; talkword9     ();
       jsr       _talkword9
; talkwordteen  ();
       jsr       _talkwordteen
       rts
; }
; void talkword20() {
_talkword20:
; talkphonemeTT2 ();
       jsr       _talkphonemeTT2
; talkphonemeWW  ();
       jsr       _talkphonemeWW
; talkphonemeEH  ();
       jsr       _talkphonemeEH
; talkphonemeNN1 ();
       jsr       _talkphonemeNN1
       rts
; }
; void talkwordty() {
_talkwordty:
; talkphonemeTT2 ();
       jsr       _talkphonemeTT2
; talkphonemeIY  ();
       jsr       _talkphonemeIY
       rts
; }
; void talkword30() {
_talkword30:
; talkphonemeTH  ();
       jsr       _talkphonemeTH
; talkphonemeER1 ();
       jsr       _talkphonemeER1
; talkwordty     ();
       jsr       _talkwordty
       rts
; }
; void talkword40() {
_talkword40:
; talkword4  ();
       jsr       _talkword4
; talkwordty ();
       jsr       _talkwordty
       rts
; }
; void talkword50() {
_talkword50:
; talkphonemeFF ();
       jsr       _talkphonemeFF
; talkphonemeIH ();
       jsr       _talkphonemeIH
; talkphonemeFF ();
       jsr       _talkphonemeFF
; talkwordty    ();
       jsr       _talkwordty
       rts
; }
; void talkword60() {
_talkword60:
; talkword6  ();
       jsr       _talkword6
; talkwordty ();
       jsr       _talkwordty
       rts
; }
; void talkword70() {
_talkword70:
; talkword7  ();
       jsr       _talkword7
; talkwordty ();
       jsr       _talkwordty
       rts
; }
; void talkword80() {
_talkword80:
; talkword8   ();
       jsr       _talkword8
; talkwordty  ();
       jsr       _talkwordty
       rts
; }
; void talkword90() {
_talkword90:
; talkword9   ();
       jsr       _talkword9
; talkwordty  ();
       jsr       _talkwordty
       rts
; }
; void talkwordhundred() {
_talkwordhundred:
; talkphonemeHH2  ();
       jsr       _talkphonemeHH2
; talkphonemeAX   ();
       jsr       _talkphonemeAX
; talkphonemeNN1  ();
       jsr       _talkphonemeNN1
; talkphonemeDD2  ();
       jsr       _talkphonemeDD2
; talkphonemeRR2  ();
       jsr       _talkphonemeRR2
; talkphonemeDD1  ();
       jsr       _talkphonemeDD1
       rts
; }
; void talkworddepth() {
_talkworddepth:
; talkphonemeDD2   ();
       jsr       _talkphonemeDD2
; talkphonemeEH    ();
       jsr       _talkphonemeEH
; talkphonemeEH    ();
       jsr       _talkphonemeEH
; talkphonemePP    ();
       jsr       _talkphonemePP
; talkphonemeTH    ();
       jsr       _talkphonemeTH
; endword          ();
       jsr       _endword
       rts
; }
; void talkwordpoint() {
_talkwordpoint:
; talkphonemePP   ();
       jsr       _talkphonemePP
; talkphonemeOY   ();
       jsr       _talkphonemeOY
; talkphonemeTT1  ();
       jsr       _talkphonemeTT1
; endword         ();
       jsr       _endword
       rts
; }
; void talkwordanchor() {
_talkwordanchor:
; talkphonemeEY   ();
       jsr       _talkphonemeEY
; talkphonemeKK3  ();
       jsr       _talkphonemeKK3
; talkphonemeAE   ();
       jsr       _talkphonemeAE
; endword         ();
       jsr       _endword
       rts
; }
; void talkwordalarm() {
_talkwordalarm:
; talkphonemeAE  ();
       jsr       _talkphonemeAE
; talkphonemeLL  ();
       jsr       _talkphonemeLL
; talkphonemeAR  ();
       jsr       _talkphonemeAR
; talkphonemeMM  ();
       jsr       _talkphonemeMM
; endword        ();
       jsr       _endword
       rts
; }
; void talkwordon() {
_talkwordon:
; talkphonemeAO ();
       jsr       _talkphonemeAO
; talkphonemeNG ();
       jsr       _talkphonemeNG
; endword       ();
       jsr       _endword
       rts
; }
; void talkwordoff() {
_talkwordoff:
; talkphonemeAO  ();
       jsr       _talkphonemeAO
; talkphonemeFF  ();
       jsr       _talkphonemeFF
; talkphonemeFF  ();
       jsr       _talkphonemeFF
; endword        ();
       jsr       _endword
       rts
; }
; void talkwordshallow() {
_talkwordshallow:
; talkphonemeSH ();
       jsr       _talkphonemeSH
; talkphonemeAE ();
       jsr       _talkphonemeAE
; talkphonemeLL ();
       jsr       _talkphonemeLL
; talkphonemeOW ();
       jsr       _talkphonemeOW
; endword       ();
       jsr       _endword
       rts
; }
; void talkwordand() {
_talkwordand:
; talkphonemeIH    ();
       jsr       _talkphonemeIH
; talkphonemeIH    ();
       jsr       _talkphonemeIH
; talkphonemeNN1   ();
       jsr       _talkphonemeNN1
; talkphonemeDD2   ();
       jsr       _talkphonemeDD2
; endword          ();
       jsr       _endword
       rts
; }
; void talkwordwatch() {
_talkwordwatch:
; talkphonemeWW  ();
       jsr       _talkphonemeWW
; talkphonemeAO  ();
       jsr       _talkphonemeAO
; talkphonemeTT1 ();
       jsr       _talkphonemeTT1
; talkphonemeCH  ();
       jsr       _talkphonemeCH
; endword        ();
       jsr       _endword
       rts
; }
; void talkwordlimit() {
_talkwordlimit:
; talkphonemeLL   ();
       jsr       _talkphonemeLL
; talkphonemeIH   ();
       jsr       _talkphonemeIH
; talkphonemeMM   ();
       jsr       _talkphonemeMM
; talkphonemeIH   ();
       jsr       _talkphonemeIH
; talkphonemeTT1  ();
       jsr       _talkphonemeTT1
; endword         ();
       jsr       _endword
       rts
; }
; void talkwordset()  {
_talkwordset:
; talkphonemeSS    ();
       jsr       _talkphonemeSS
; talkphonemeSS    ();
       jsr       _talkphonemeSS
; talkphonemeEH    ();
       jsr       _talkphonemeEH
; talkphonemeTT2   ();
       jsr       _talkphonemeTT2
; endword          ();
       jsr       _endword
       rts
; }
; void talkwordheading() {
_talkwordheading:
; talkphonemeHH1   ();
       jsr       _talkphonemeHH1
; talkphonemeEH    ();
       jsr       _talkphonemeEH
; talkphonemeDD2   ();
       jsr       _talkphonemeDD2
; talkphonemeIH    ();
       jsr       _talkphonemeIH
; talkphonemeNG    ();
       jsr       _talkphonemeNG
; endword          ();
       jsr       _endword
       rts
; }
; void talkwordgps() {
_talkwordgps:
; talkphonemeJH  ();
       jsr       _talkphonemeJH
; talkphonemeIY  ();
       jsr       _talkphonemeIY
; talkphonemePP  ();
       jsr       _talkphonemePP
; talkphonemeIY  ();
       jsr       _talkphonemeIY
; talkphonemeEH  ();
       jsr       _talkphonemeEH
; talkphonemeSS  ();
       jsr       _talkphonemeSS
; talkphonemeSS  ();
       jsr       _talkphonemeSS
; endword        ();
       jsr       _endword
       rts
; }
; void talkwordno() {
_talkwordno:
; talkphonemeNN2  ();
       jsr       _talkphonemeNN2
; talkphonemeOW   ();
       jsr       _talkphonemeOW
; endword         ();
       jsr       _endword
       rts
; }
; void talkworddata() {
_talkworddata:
; talkphonemeDD2   ();
       jsr       _talkphonemeDD2
; talkphonemeEY    ();
       jsr       _talkphonemeEY
; talkphonemeTT2   ();
       jsr       _talkphonemeTT2
; talkphonemeAX    ();
       jsr       _talkphonemeAX
; endword          ();
       jsr       _endword
       rts
; }
; void talkwordnorth() {
_talkwordnorth:
; talkphonemeNN2 ();
       jsr       _talkphonemeNN2
; talkphonemeOR  ();
       jsr       _talkphonemeOR
; talkphonemeHH1 ();
       jsr       _talkphonemeHH1
; endword        ();
       jsr       _endword
       rts
; }
; void talkwordsouth() {
_talkwordsouth:
; talkphonemeSS();
       jsr       _talkphonemeSS
; talkphonemeSS();
       jsr       _talkphonemeSS
; talkphonemeAW();
       jsr       _talkphonemeAW
; talkphonemeTH();
       jsr       _talkphonemeTH
; talkphonemeTH();
       jsr       _talkphonemeTH
       rts
; }
; void talkwordeast() {
_talkwordeast:
; talkphonemeIY   ();
       jsr       _talkphonemeIY
; talkphonemeSS   ();
       jsr       _talkphonemeSS
; talkphonemeSS   ();
       jsr       _talkphonemeSS
; talkphonemeTT2  ();
       jsr       _talkphonemeTT2
; endword         ();
       jsr       _endword
       rts
; }
; void talkwordwest() {
_talkwordwest:
; talkphonemeWW     ();
       jsr       _talkphonemeWW
; talkphonemeEH     ();
       jsr       _talkphonemeEH
; talkphonemeSS     ();
       jsr       _talkphonemeSS
; talkphonemeSS     ();
       jsr       _talkphonemeSS
; talkphonemeTT2    ();
       jsr       _talkphonemeTT2
; endword           ();
       jsr       _endword
       rts
; }
; void talkwordposition() {
_talkwordposition:
; talkphonemePP   ();
       jsr       _talkphonemePP
; talkphonemeIH   ();
       jsr       _talkphonemeIH
; talkphonemeZZ   ();
       jsr       _talkphonemeZZ
; talkphonemeIH   ();
       jsr       _talkphonemeIH
; talkphonemeSH   ();
       jsr       _talkphonemeSH
; talkphonemeNN1  ();
       jsr       _talkphonemeNN1
; endword         ();
       jsr       _endword
       rts
; }
; void talkphonemePA6() {
_talkphonemePA6:
; talkphonemePA5();
       jsr       _talkphonemePA5
; talkphonemePA5();
       jsr       _talkphonemePA5
; talkphonemePA4();
       jsr       _talkphonemePA4
       rts
; }
; void endword() {
_endword:
; talkphonemePA5();
       jsr       _talkphonemePA5
; talkphonemePA4();
       jsr       _talkphonemePA4
       rts
; }
; C:\USERS\10054\ONEDRIVE\CPEN 412 FINAL PROJECT\FINAL_PROJECT_2023_SEM2_STUDENT_TEMPLATE\FINAL_PROJECT_2023_SEM2_STUDENT_TEMPLATE\PROGRAMS\DEBUGMONITORCODE\TETRIS.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
; #include <stdio.h>
; #include <stdlib.h>
; #include <limits.h>
; #include "tetris.h"
; #include "say_phoneme.h"
; #define Timer1Data *(volatile unsigned char *)(0x00400030)
; #define Timer1Control *(volatile unsigned char *)(0x00400032)
; #define Timer1Status *(volatile unsigned char *)(0x00400032)
; #define octlAddress1 *(char *)(0xFF030001)
; #define octlAddress *(char *)(0xFF030000)
; char Table[TETRIS_ROWS][TETRIS_COLS];
; char TableColor[TETRIS_ROWS + 1][TETRIS_COLS];
; char currentColor;
; int tetris_score;
; char GameOn;
; int tetris_timer;
; char octl;
; typedef struct
; {
; char array[MAX_SHAPE_SIZE][MAX_SHAPE_SIZE];
; int width, row, col;
; } Shape;
; Shape current;
; Shape ShapesArray[NUM_SHAPES];
; struct
; {
; int speed;
; int speed_increase;
; } Tetris_Speed;
; int printw_x; // hint: could be a useful variable
; int printw_y; // hint: could be a useful variable
; char cx, cy;
; int timer_count;
; /* Compute x mod y using binary long division. */
; int mod_bld(int x, int y)
; {
_mod_bld:
       link      A6,#0
       movem.l   D2/D3,-(A7)
; int modulus = x, divisor = y;
       move.l    8(A6),D3
       move.l    12(A6),D2
; while (divisor <= modulus && divisor <= 16384)
mod_bld_1:
       cmp.l     D3,D2
       bgt.s     mod_bld_3
       cmp.l     #16384,D2
       bgt.s     mod_bld_3
; divisor <<= 1;
       asl.l     #1,D2
       bra       mod_bld_1
mod_bld_3:
; while (modulus >= y)
mod_bld_4:
       cmp.l     12(A6),D3
       blt.s     mod_bld_6
; {
; while (divisor > modulus)
mod_bld_7:
       cmp.l     D3,D2
       ble.s     mod_bld_9
; divisor >>= 1;
       asr.l     #1,D2
       bra       mod_bld_7
mod_bld_9:
; modulus -= divisor;
       sub.l     D2,D3
       bra       mod_bld_4
mod_bld_6:
; }
; return modulus;
       move.l    D3,D0
       movem.l   (A7)+,D2/D3
       unlk      A6
       rts
; }
; /////////////////////////////////////////////////////////////////////////////////////////////////////
; //
; //
; //                        functions to implement
; //
; //
; /////////////////////////////////////////////////////////////////////////////////////////////////////
; void Timer_ISR()
; {
_Timer_ISR:
; ++timer_count;
       addq.l    #1,_timer_count.L
; // printf("Timer ISR, %d\n", timer_count);
; Timer1Control = 3;
       move.b    #3,4194354
       rts
; }
; // #define StartOfExceptionVectorTable 0x08030000
; // void InstallExceptionHandler(void (*function_ptr)(), int level)
; // {
; //     volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable); // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
; //     RamVectorAddress[level] = (long int *)(function_ptr); // install the address of our function into the exception table
; // }
; void Wait1ms_here(void)
; {
_Wait1ms_here:
       move.l    D2,-(A7)
; int what;
; for (what = 0; what < 1000; what++)
       clr.l     D2
Wait1ms_here_1:
       cmp.l     #1000,D2
       bge.s     Wait1ms_here_3
       addq.l    #1,D2
       bra       Wait1ms_here_1
Wait1ms_here_3:
       move.l    (A7)+,D2
       rts
; ;
; }
; void Wait250ms_here(void)
; {
_Wait250ms_here:
       move.l    D2,-(A7)
; int what;
; for (what = 0; what < 250; what++)
       clr.l     D2
Wait250ms_here_1:
       cmp.l     #250,D2
       bge.s     Wait250ms_here_3
; Wait1ms_here();
       jsr       _Wait1ms_here
       addq.l    #1,D2
       bra       Wait250ms_here_1
Wait250ms_here_3:
       move.l    (A7)+,D2
       rts
; }
; void changeChar(int addr, char c)
; {
_changeChar:
       link      A6,#0
; *(char *)(VGA_ADDRESS + addr * 2 + 1) = c;
       move.l    #-65536,D0
       move.l    8(A6),-(A7)
       pea       2
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       addq.l    #1,D1
       add.l     D1,D0
       move.l    D0,A0
       move.b    15(A6),(A0)
; *(char *)(VGA_ADDRESS + addr * 2) = c;
       move.l    #-65536,D0
       move.l    8(A6),-(A7)
       pea       2
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       add.l     D1,D0
       move.l    D0,A0
       move.b    15(A6),(A0)
       unlk      A6
       rts
; }
; void changeColor(int addr, char color)
; {
_changeColor:
       link      A6,#0
       move.l    D2,-(A7)
; char change = octl & 0xF8;
       move.b    _octl.L,D0
       ext.w     D0
       and.w     #248,D0
       move.b    D0,D2
; change |= color;
       move.b    15(A6),D0
       or.b      D0,D2
; octlAddress = change;
       move.b    D2,-16580608
; octlAddress1 = change;
       move.b    D2,-16580607
       move.l    (A7)+,D2
       unlk      A6
       rts
; }
; void writeVGAColor(int addr, char c, char color)
; {
_writeVGAColor:
       link      A6,#0
; changeColor(addr, color);
       move.b    19(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    8(A6),-(A7)
       jsr       _changeColor
       addq.w    #8,A7
; changeChar(addr, c);
       move.b    15(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    8(A6),-(A7)
       jsr       _changeChar
       addq.w    #8,A7
       unlk      A6
       rts
; }
; void writeVGA(int addr, char c)
; {
_writeVGA:
       link      A6,#0
; changeColor(addr, octl);
       move.b    _octl.L,D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    8(A6),-(A7)
       jsr       _changeColor
       addq.w    #8,A7
; changeChar(addr, c);
       move.b    15(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    8(A6),-(A7)
       jsr       _changeChar
       addq.w    #8,A7
       unlk      A6
       rts
; }
; void updateVGAColor(int x, int y, char c, char color)
; {
_updateVGAColor:
       link      A6,#0
; writeVGAColor(y * screen_width + x, c, color);
       move.b    23(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.b    19(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    12(A6),-(A7)
       pea       80
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       add.l     8(A6),D1
       move.l    D1,-(A7)
       jsr       _writeVGAColor
       add.w     #12,A7
       unlk      A6
       rts
; }
; void updateVGA(int x, int y, char c)
; {
_updateVGA:
       link      A6,#0
; writeVGA(y * screen_width + x, c);
       move.b    19(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    12(A6),-(A7)
       pea       80
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       add.l     8(A6),D1
       move.l    D1,-(A7)
       jsr       _writeVGA
       addq.w    #8,A7
       unlk      A6
       rts
; }
; void update_cursor(int x, int y)
; {
_update_cursor:
       link      A6,#0
; cx = x;
       move.l    8(A6),D0
       move.b    D0,_cx.L
; cy = y;
       move.l    12(A6),D0
       move.b    D0,_cy.L
; cursor_x = cx;
       move.b    _cx.L,-16711680
; cursor_x1 = cx;
       move.b    _cx.L,-16711679
; cursor_y = cy;
       move.b    _cy.L,-16711678
; cursor_y1 = cy;
       move.b    _cy.L,-16711677
       unlk      A6
       rts
; }
; void go_to_top_corner()
; {
_go_to_top_corner:
; update_cursor(0, 0);
       clr.l     -(A7)
       clr.l     -(A7)
       jsr       _update_cursor
       addq.w    #8,A7
       rts
; };
; void clear_screen()
; {
_clear_screen:
       move.l    D2,-(A7)
; int i;
; for (i = 0; i <= 3200; i++)
       clr.l     D2
clear_screen_1:
       cmp.l     #3200,D2
       bgt.s     clear_screen_3
; {
; changeChar(i, ' ');
       pea       32
       move.l    D2,-(A7)
       jsr       _changeChar
       addq.w    #8,A7
       addq.l    #1,D2
       bra       clear_screen_1
clear_screen_3:
       move.l    (A7)+,D2
       rts
; }
; };
; void say_game_over()
; {
_say_game_over:
; talkphonemeGG2();
       jsr       _talkphonemeGG2
; talkphonemeEY();
       jsr       _talkphonemeEY
; talkphonemeMM();
       jsr       _talkphonemeMM
; endword();
       jsr       _endword
; talkphonemeOW();
       jsr       _talkphonemeOW
; talkphonemeVV();
       jsr       _talkphonemeVV
; talkphonemeER2();
       jsr       _talkphonemeER2
; endword();
       jsr       _endword
       rts
; }
; void say_awesome()
; {
_say_awesome:
; talkphonemeAA();
       jsr       _talkphonemeAA
; talkphonemeSS();
       jsr       _talkphonemeSS
; talkphonemeAO();
       jsr       _talkphonemeAO
; talkphonemeMM();
       jsr       _talkphonemeMM
; endword();
       jsr       _endword
       rts
; }
; void say_cool()
; {
_say_cool:
; talkphonemeKK2();
       jsr       _talkphonemeKK2
; talkphonemeUW2();
       jsr       _talkphonemeUW2
; talkphonemeEL();
       jsr       _talkphonemeEL
; endword();
       jsr       _endword
       rts
; }
; void say_yeah()
; {
_say_yeah:
; talkphonemeYY1();
       jsr       _talkphonemeYY1
; talkphonemeEH();
       jsr       _talkphonemeEH
; talkphonemeEH();
       jsr       _talkphonemeEH
; endword();
       jsr       _endword
       rts
; }
; void putcharxyColor(int x, int y, char ch, char color, char *error_message)
; {
_putcharxyColor:
       link      A6,#0
       movem.l   D2/D3,-(A7)
       move.l    12(A6),D2
       move.l    8(A6),D3
; if (x < 0 || x >= screen_width || y < 0 || y >= screen_height)
       cmp.l     #0,D3
       blt.s     putcharxyColor_3
       cmp.l     #80,D3
       bge.s     putcharxyColor_3
       cmp.l     #0,D2
       blt.s     putcharxyColor_3
       cmp.l     #40,D2
       blt.s     putcharxyColor_1
putcharxyColor_3:
; {
; printf("%s\n", error_message);
       move.l    24(A6),-(A7)
       pea       @tetris_1.L
       jsr       _printf
       addq.w    #8,A7
       bra.s     putcharxyColor_2
putcharxyColor_1:
; // printf("x: %d, y: %d\n", x, y);
; }
; else
; {
; updateVGAColor(x, y, ch, color);
       move.b    23(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.b    19(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    D2,-(A7)
       move.l    D3,-(A7)
       jsr       _updateVGAColor
       add.w     #16,A7
putcharxyColor_2:
       movem.l   (A7)+,D2/D3
       unlk      A6
       rts
; }
; }
; // default color
; void putcharxy(int x, int y, char ch, char *error_message)
; {
_putcharxy:
       link      A6,#0
       movem.l   D2/D3,-(A7)
       move.l    12(A6),D2
       move.l    8(A6),D3
; if (x < 0 || x >= screen_width || y < 0 || y >= screen_height)
       cmp.l     #0,D3
       blt.s     putcharxy_3
       cmp.l     #80,D3
       bge.s     putcharxy_3
       cmp.l     #0,D2
       blt.s     putcharxy_3
       cmp.l     #40,D2
       blt.s     putcharxy_1
putcharxy_3:
; {
; printf("%s\n", error_message);
       move.l    20(A6),-(A7)
       pea       @tetris_1.L
       jsr       _printf
       addq.w    #8,A7
       bra.s     putcharxy_2
putcharxy_1:
; // printf("x: %d, y: %d\n", x, y);
; }
; else
; {
; updateVGA(x, y, ch);
       move.b    19(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    D2,-(A7)
       move.l    D3,-(A7)
       jsr       _updateVGA
       add.w     #12,A7
putcharxy_2:
       movem.l   (A7)+,D2/D3
       unlk      A6
       rts
; }
; }
; void gotoxy(int x, int y)
; {
_gotoxy:
       link      A6,#0
; update_cursor(x, y);
       move.l    12(A6),-(A7)
       move.l    8(A6),-(A7)
       jsr       _update_cursor
       addq.w    #8,A7
       unlk      A6
       rts
; };
; void set_vga_control_reg(char x)
; {
_set_vga_control_reg:
       link      A6,#0
; // Set the value of the control register in the VGA core
; // write this function
; octl = (x & 0xF8) | (octl & 0x7);
       move.b    11(A6),D0
       ext.w     D0
       and.w     #248,D0
       move.b    _octl.L,D1
       and.b     #7,D1
       ext.w     D1
       or.w      D1,D0
       move.b    D0,_octl.L
       unlk      A6
       rts
; }
; char get_vga_control_reg()
; {
_get_vga_control_reg:
; // Get the value of the control register in the VGA core
; // write this function
; return octl;
       move.b    _octl.L,D0
       rts
; }
; void set_color(int color)
; {
_set_color:
       link      A6,#0
; octl &= 0xF8;		   // 8'b1111_1000
       and.b     #248,_octl.L
; octl |= (color & 0x7); // 8'b0000_0111
       move.l    8(A6),D0
       and.l     #7,D0
       or.b      D0,_octl.L
       unlk      A6
       rts
; }
; int clock()
; {
_clock:
; // Returns time in milliseconds since the timer was initialized
; // write this function
; return timer_count * 100;
       move.l    _timer_count.L,-(A7)
       pea       100
       jsr       LMUL
       move.l    (A7),D0
       addq.w    #8,A7
       rts
; }
; void printwColor(const char *str, char color, char *error_message)
; {
_printwColor:
       link      A6,#0
       movem.l   D2/D3/A2,-(A7)
       lea       _printw_x.L,A2
       move.l    8(A6),D3
; int index = 0;
       clr.l     D2
; while (str[index] != '\0')
printwColor_1:
       move.l    D3,A0
       move.b    0(A0,D2.L),D0
       beq       printwColor_3
; {
; if (str[index] == '\n')
       move.l    D3,A0
       move.b    0(A0,D2.L),D0
       cmp.b     #10,D0
       bne.s     printwColor_4
; {
; printw_x = 0;
       clr.l     (A2)
; printw_y++;
       addq.l    #1,_printw_y.L
       bra.s     printwColor_5
printwColor_4:
; // printf("newline\n");
; }
; else
; {
; putcharxyColor(printw_x, printw_y, str[index], color, error_message);
       move.l    16(A6),-(A7)
       move.b    15(A6),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    D3,A0
       move.b    0(A0,D2.L),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    _printw_y.L,-(A7)
       move.l    (A2),-(A7)
       jsr       _putcharxyColor
       add.w     #20,A7
; printw_x++;
       addq.l    #1,(A2)
printwColor_5:
; }
; index++;
       addq.l    #1,D2
       bra       printwColor_1
printwColor_3:
       movem.l   (A7)+,D2/D3/A2
       unlk      A6
       rts
; }
; }
; // default color
; void printw(const char *str, char *error_message)
; {
_printw:
       link      A6,#0
       movem.l   D2/D3/A2,-(A7)
       lea       _printw_x.L,A2
       move.l    8(A6),D3
; int index = 0;
       clr.l     D2
; while (str[index] != '\0')
printw_1:
       move.l    D3,A0
       move.b    0(A0,D2.L),D0
       beq       printw_3
; {
; if (str[index] == '\n')
       move.l    D3,A0
       move.b    0(A0,D2.L),D0
       cmp.b     #10,D0
       bne.s     printw_4
; {
; printw_x = 0;
       clr.l     (A2)
; printw_y++;
       addq.l    #1,_printw_y.L
       bra.s     printw_5
printw_4:
; // printf("newline\n");
; }
; else
; {
; putcharxy(printw_x, printw_y, str[index], error_message);
       move.l    12(A6),-(A7)
       move.l    D3,A0
       move.b    0(A0,D2.L),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    _printw_y.L,-(A7)
       move.l    (A2),-(A7)
       jsr       _putcharxy
       add.w     #16,A7
; printw_x++;
       addq.l    #1,(A2)
printw_5:
; }
; index++;
       addq.l    #1,D2
       bra       printw_1
printw_3:
       movem.l   (A7)+,D2/D3/A2
       unlk      A6
       rts
; }
; }
; void display_game_over(char *str, int x, int y)
; {
_display_game_over:
       link      A6,#0
       movem.l   D2/D3/D4/D5,-(A7)
       move.l    12(A6),D2
       move.l    16(A6),D3
       move.l    8(A6),D5
; int num;
; num = 0;
       clr.l     D4
; while (str[num] != '\0')
display_game_over_1:
       move.l    D5,A0
       move.b    0(A0,D4.L),D0
       beq       display_game_over_3
; {
; Wait250ms_here();
       jsr       _Wait250ms_here
; update_cursor(x + 1, y);
       move.l    D3,-(A7)
       move.l    D2,D1
       addq.l    #1,D1
       move.l    D1,-(A7)
       jsr       _update_cursor
       addq.w    #8,A7
; putcharxy(x + 1, y, ' ', "game over");
       pea       @tetris_2.L
       pea       32
       move.l    D3,-(A7)
       move.l    D2,D1
       addq.l    #1,D1
       move.l    D1,-(A7)
       jsr       _putcharxy
       add.w     #16,A7
; // printf("cx: %d, cy: %d\n", cx, cy);
; Wait1ms_here();
       jsr       _Wait1ms_here
; putcharxy(x, y, str[num], "game over");
       pea       @tetris_2.L
       move.l    D5,A0
       move.b    0(A0,D4.L),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    D3,-(A7)
       move.l    D2,-(A7)
       jsr       _putcharxy
       add.w     #16,A7
; x++;
       addq.l    #1,D2
; num++;
       addq.l    #1,D4
       bra       display_game_over_1
display_game_over_3:
; }
; if (str[0] == 'S')
       move.l    D5,A0
       move.b    (A0),D0
       cmp.b     #83,D0
       bne.s     display_game_over_4
; update_cursor(x - 1, y);
       move.l    D3,-(A7)
       move.l    D2,D1
       subq.l    #1,D1
       move.l    D1,-(A7)
       jsr       _update_cursor
       addq.w    #8,A7
display_game_over_4:
       movem.l   (A7)+,D2/D3/D4/D5
       unlk      A6
       rts
; }
; void gameOver()
; {
_gameOver:
       link      A6,#-132
       movem.l   D2/D3/A2/A3/A4,-(A7)
       lea       _printw_y.L,A2
       lea       _printw_x.L,A3
       lea       -128(A6),A4
; // 36, 20: Game over!
; int test = 5000;
       move.l    #5000,-132(A6)
; char *game_over = " Game over! ";
       lea       @tetris_3.L,A0
       move.l    A0,D3
; char score_str[128];
; char num;
; say_game_over();
       jsr       _say_game_over
; clear_screen();
       jsr       _clear_screen
; num = 1;
       moveq     #1,D2
; sprintf(score_str, " Score: %d ", tetris_score);
       move.l    _tetris_score.L,-(A7)
       pea       @tetris_4.L
       move.l    A4,-(A7)
       jsr       _sprintf
       add.w     #12,A7
; // 36, 22: Score: %d
; set_vga_control_reg(0xE0);
       pea       224
       jsr       _set_vga_control_reg
       addq.w    #4,A7
; printw_x = 34;
       move.l    #34,(A3)
; printw_y = 20;
       move.l    #20,(A2)
; display_game_over(game_over, printw_x, printw_y);
       move.l    (A2),-(A7)
       move.l    (A3),-(A7)
       move.l    D3,-(A7)
       jsr       _display_game_over
       add.w     #12,A7
; printw_x = 34;
       move.l    #34,(A3)
; printw_y = 22;
       move.l    #22,(A2)
; display_game_over(score_str, printw_x, printw_y);
       move.l    (A2),-(A7)
       move.l    (A3),-(A7)
       move.l    A4,-(A7)
       jsr       _display_game_over
       add.w     #12,A7
; FlushKeyboard() ; 
       jsr       _FlushKeyboard
; printf("Press any key to continue\n");
       pea       @tetris_5.L
       jsr       _printf
       addq.w    #4,A7
; while (1)
gameOver_1:
; {
; printw_x = 34;
       move.l    #34,(A3)
; printw_y = 20;
       move.l    #20,(A2)
; set_color(num);
       ext.w     D2
       ext.l     D2
       move.l    D2,-(A7)
       jsr       _set_color
       addq.w    #4,A7
; printw(game_over, "game over");
       pea       @tetris_2.L
       move.l    D3,-(A7)
       jsr       _printw
       addq.w    #8,A7
; printw_x = 34;
       move.l    #34,(A3)
; printw_y = 22;
       move.l    #22,(A2)
; printw(score_str, "score");
       pea       @tetris_6.L
       move.l    A4,-(A7)
       jsr       _printw
       addq.w    #8,A7
; if (kbhit())
       jsr       _kbhit
       tst.l     D0
       beq.s     gameOver_4
; {
; break;
       bra.s     gameOver_3
gameOver_4:
; }
; Wait250ms_here();
       jsr       _Wait250ms_here
; ++num;
       addq.b    #1,D2
; if (num > 7)
       cmp.b     #7,D2
       ble.s     gameOver_6
; {
; num = 1;
       moveq     #1,D2
gameOver_6:
       bra       gameOver_1
gameOver_3:
; }
; }
; set_vga_control_reg(0xA2);
       pea       162
       jsr       _set_vga_control_reg
       addq.w    #4,A7
       movem.l   (A7)+,D2/D3/A2/A3/A4
       unlk      A6
       rts
; }
; /////////////////////////////////////////////////////////////////////////////////////////////////////
; //
; //
; //                      end  functions to implement
; //
; //
; /////////////////////////////////////////////////////////////////////////////////////////////////////
; void delay_ms(int num_ms)
; {
_delay_ms:
       link      A6,#0
       movem.l   D2/D3,-(A7)
; int start_time;
; int current_time;
; start_time = clock();
       jsr       _clock
       move.l    D0,D2
; do
; {
delay_ms_1:
; current_time = clock();
       jsr       _clock
       move.l    D0,D3
; if (current_time < start_time)
       cmp.l     D2,D3
       bge.s     delay_ms_3
; { // handle wraparound
; num_ms = num_ms - (INT_MAX - start_time);
       move.l    #2147483647,D0
       sub.l     D2,D0
       sub.l     D0,8(A6)
; start_time = current_time;
       move.l    D3,D2
delay_ms_3:
       move.l    D3,D0
       sub.l     D2,D0
       cmp.l     8(A6),D0
       blt       delay_ms_1
       movem.l   (A7)+,D2/D3
       unlk      A6
       rts
; }
; } while ((current_time - start_time) < num_ms);
; }
; int tetris_rand()
; {
_tetris_rand:
; return ((clock() >> 4) & 0xFFFF); // divide by 4 because clock increases by 10 every interrupt, ensure last digit is "random" too
       jsr       _clock
       asr.l     #4,D0
       and.l     #65535,D0
       rts
; }
; void CopyShape(Shape *shape, Shape *new_shape)
; {
_CopyShape:
       link      A6,#0
       movem.l   D2/D3/D4/D5,-(A7)
       move.l    12(A6),D2
       move.l    8(A6),D5
; int i;
; int j;
; new_shape->width = shape->width;
       move.l    D5,A0
       move.l    D2,A1
       move.l    16(A0),16(A1)
; new_shape->row = shape->row;
       move.l    D5,A0
       move.l    D2,A1
       move.l    20(A0),20(A1)
; new_shape->col = shape->col;
       move.l    D5,A0
       move.l    D2,A1
       move.l    24(A0),24(A1)
; for (i = 0; i < new_shape->width; i++)
       clr.l     D4
CopyShape_1:
       move.l    D2,A0
       cmp.l     16(A0),D4
       bge       CopyShape_3
; {
; for (j = 0; j < new_shape->width; j++)
       clr.l     D3
CopyShape_4:
       move.l    D2,A0
       cmp.l     16(A0),D3
       bge.s     CopyShape_6
; {
; new_shape->array[i][j] = shape->array[i][j];
       move.l    D5,A0
       move.l    D4,D0
       lsl.l     #2,D0
       add.l     D0,A0
       move.l    D2,A1
       move.l    D4,D0
       lsl.l     #2,D0
       add.l     D0,A1
       move.b    0(A0,D3.L),0(A1,D3.L)
       addq.l    #1,D3
       bra       CopyShape_4
CopyShape_6:
       addq.l    #1,D4
       bra       CopyShape_1
CopyShape_3:
       movem.l   (A7)+,D2/D3/D4/D5
       unlk      A6
       rts
; }
; }
; }
; int CheckPosition(Shape *shape)
; { // Check the position of the copied shape
_CheckPosition:
       link      A6,#0
       movem.l   D2/D3/D4,-(A7)
       move.l    8(A6),D2
; int i, j;
; for (i = 0; i < shape->width; i++)
       clr.l     D4
CheckPosition_1:
       move.l    D2,A0
       cmp.l     16(A0),D4
       bge       CheckPosition_3
; {
; for (j = 0; j < shape->width; j++)
       clr.l     D3
CheckPosition_4:
       move.l    D2,A0
       cmp.l     16(A0),D3
       bge       CheckPosition_6
; {
; if ((shape->col + j < 0 || shape->col + j >= TETRIS_COLS || shape->row + i >= TETRIS_ROWS))
       move.l    D2,A0
       move.l    24(A0),D0
       add.l     D3,D0
       cmp.l     #0,D0
       blt.s     CheckPosition_9
       move.l    D2,A0
       move.l    24(A0),D0
       add.l     D3,D0
       cmp.l     #15,D0
       bge.s     CheckPosition_9
       move.l    D2,A0
       move.l    20(A0),D0
       add.l     D4,D0
       cmp.l     #20,D0
       blt.s     CheckPosition_7
CheckPosition_9:
; {							// Out of borders
; if (shape->array[i][j]) // but is it just a phantom?
       move.l    D2,A0
       move.l    D4,D0
       lsl.l     #2,D0
       add.l     D0,A0
       tst.b     0(A0,D3.L)
       beq.s     CheckPosition_10
; return FALSE;
       clr.l     D0
       bra       CheckPosition_12
CheckPosition_10:
       bra       CheckPosition_13
CheckPosition_7:
; }
; else if (Table[shape->row + i][shape->col + j] && shape->array[i][j])
       move.l    D2,A0
       move.l    20(A0),D0
       add.l     D4,D0
       muls      #15,D0
       lea       _Table.L,A0
       add.l     D0,A0
       move.l    D2,A1
       move.l    24(A1),D0
       add.l     D3,D0
       tst.b     0(A0,D0.L)
       beq.s     CheckPosition_13
       move.l    D2,A0
       move.l    D4,D0
       lsl.l     #2,D0
       add.l     D0,A0
       tst.b     0(A0,D3.L)
       beq.s     CheckPosition_13
; return FALSE;
       clr.l     D0
       bra.s     CheckPosition_12
CheckPosition_13:
       addq.l    #1,D3
       bra       CheckPosition_4
CheckPosition_6:
       addq.l    #1,D4
       bra       CheckPosition_1
CheckPosition_3:
; }
; }
; return TRUE;
       moveq     #1,D0
CheckPosition_12:
       movem.l   (A7)+,D2/D3/D4
       unlk      A6
       rts
; }
; void SetNewRandomShape()
; { // updates [current] with new shape
_SetNewRandomShape:
       move.l    A2,-(A7)
       lea       _current.L,A2
; currentColor = mod_bld(tetris_rand(), NUM_SHAPES);
       pea       7
       move.l    D0,-(A7)
       jsr       _tetris_rand
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _mod_bld
       addq.w    #8,A7
       move.b    D0,_currentColor.L
; CopyShape(&ShapesArray[currentColor], &current);
       move.l    A2,-(A7)
       lea       _ShapesArray.L,A0
       move.b    _currentColor.L,D1
       ext.w     D1
       ext.l     D1
       muls      #28,D1
       add.l     D1,A0
       move.l    A0,-(A7)
       jsr       _CopyShape
       addq.w    #8,A7
; ++currentColor;
       addq.b    #1,_currentColor.L
; current.col = mod_bld(tetris_rand(), (TETRIS_COLS - current.width + 1));
       moveq     #15,D1
       ext.w     D1
       ext.l     D1
       sub.l     16(A2),D1
       addq.l    #1,D1
       move.l    D1,-(A7)
       move.l    D0,-(A7)
       jsr       _tetris_rand
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _mod_bld
       addq.w    #8,A7
       move.l    D0,24(A2)
; current.row = 0;
       clr.l     20(A2)
; if (!CheckPosition(&current))
       move.l    A2,-(A7)
       jsr       _CheckPosition
       addq.w    #4,A7
       tst.l     D0
       bne.s     SetNewRandomShape_1
; {
; GameOn = FALSE;
       clr.b     _GameOn.L
SetNewRandomShape_1:
       move.l    (A7)+,A2
       rts
; // printf("Game on = false\n");
; }
; }
; void RotateShape(Shape *shape)
; { // rotates clockwise
_RotateShape:
       link      A6,#-28
       movem.l   D2/D3/D4/D5/D6,-(A7)
       move.l    8(A6),D6
; Shape temp;
; int i, j, k, width;
; CopyShape(shape, &temp);
       pea       -28(A6)
       move.l    D6,-(A7)
       jsr       _CopyShape
       addq.w    #8,A7
; width = shape->width;
       move.l    D6,A0
       move.l    16(A0),D4
; for (i = 0; i < width; i++)
       clr.l     D2
RotateShape_1:
       cmp.l     D4,D2
       bge       RotateShape_3
; {
; for (j = 0, k = width - 1; j < width; j++, k--)
       clr.l     D3
       move.l    D4,D0
       subq.l    #1,D0
       move.l    D0,D5
RotateShape_4:
       cmp.l     D4,D3
       bge.s     RotateShape_6
; {
; shape->array[i][j] = temp.array[k][i];
       lea       -28(A6),A0
       move.l    D5,D0
       lsl.l     #2,D0
       add.l     D0,A0
       move.l    D6,A1
       move.l    D2,D0
       lsl.l     #2,D0
       add.l     D0,A1
       move.b    0(A0,D2.L),0(A1,D3.L)
       addq.l    #1,D3
       subq.l    #1,D5
       bra       RotateShape_4
RotateShape_6:
       addq.l    #1,D2
       bra       RotateShape_1
RotateShape_3:
       movem.l   (A7)+,D2/D3/D4/D5/D6
       unlk      A6
       rts
; }
; }
; }
; void WriteToTable()
; {
_WriteToTable:
       movem.l   D2/D3/A2,-(A7)
       lea       _current.L,A2
; int i, j;
; for (i = 0; i < current.width; i++)
       clr.l     D3
WriteToTable_1:
       cmp.l     16(A2),D3
       bge       WriteToTable_3
; {
; for (j = 0; j < current.width; j++)
       clr.l     D2
WriteToTable_4:
       cmp.l     16(A2),D2
       bge       WriteToTable_6
; {
; if (current.array[i][j])
       move.l    D3,D0
       lsl.l     #2,D0
       lea       0(A2,D0.L),A0
       tst.b     0(A0,D2.L)
       beq.s     WriteToTable_7
; Table[current.row + i][current.col + j] = current.array[i][j];
       move.l    D3,D0
       lsl.l     #2,D0
       lea       0(A2,D0.L),A0
       move.l    20(A2),D0
       add.l     D3,D0
       muls      #15,D0
       lea       _Table.L,A1
       add.l     D0,A1
       move.l    24(A2),D0
       add.l     D2,D0
       move.b    0(A0,D2.L),0(A1,D0.L)
WriteToTable_7:
       addq.l    #1,D2
       bra       WriteToTable_4
WriteToTable_6:
       addq.l    #1,D3
       bra       WriteToTable_1
WriteToTable_3:
       movem.l   (A7)+,D2/D3/A2
       rts
; }
; }
; }
; void RemoveFullRowsAndUpdateScore()
; {
_RemoveFullRowsAndUpdateScore:
       link      A6,#-4
       movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
       lea       _Table.L,A2
       lea       _Tetris_Speed.L,A3
; int i, j, sum, count = 0;
       moveq     #0,D7
; int l, k;
; int compliment_to_say;
; for (i = 0; i < TETRIS_ROWS; i++)
       clr.l     D4
RemoveFullRowsAndUpdateScore_1:
       cmp.l     #20,D4
       bge       RemoveFullRowsAndUpdateScore_3
; {
; sum = 0;
       clr.l     D6
; for (j = 0; j < TETRIS_COLS; j++)
       clr.l     D5
RemoveFullRowsAndUpdateScore_4:
       cmp.l     #15,D5
       bge.s     RemoveFullRowsAndUpdateScore_6
; {
; sum += Table[i][j];
       move.l    D4,D0
       muls      #15,D0
       lea       0(A2,D0.L),A0
       move.b    0(A0,D5.L),D0
       ext.w     D0
       ext.l     D0
       add.l     D0,D6
       addq.l    #1,D5
       bra       RemoveFullRowsAndUpdateScore_4
RemoveFullRowsAndUpdateScore_6:
; }
; if (sum == TETRIS_COLS)
       cmp.l     #15,D6
       bne       RemoveFullRowsAndUpdateScore_7
; {
; count++;
       addq.l    #1,D7
; for (k = i; k >= 1; k--)
       move.l    D4,D3
RemoveFullRowsAndUpdateScore_9:
       cmp.l     #1,D3
       blt.s     RemoveFullRowsAndUpdateScore_11
; for (l = 0; l < TETRIS_COLS; l++)
       clr.l     D2
RemoveFullRowsAndUpdateScore_12:
       cmp.l     #15,D2
       bge.s     RemoveFullRowsAndUpdateScore_14
; Table[k][l] = Table[k - 1][l];
       move.l    D3,D0
       subq.l    #1,D0
       muls      #15,D0
       lea       0(A2,D0.L),A0
       move.l    D3,D0
       muls      #15,D0
       lea       0(A2,D0.L),A1
       move.b    0(A0,D2.L),0(A1,D2.L)
       addq.l    #1,D2
       bra       RemoveFullRowsAndUpdateScore_12
RemoveFullRowsAndUpdateScore_14:
       subq.l    #1,D3
       bra       RemoveFullRowsAndUpdateScore_9
RemoveFullRowsAndUpdateScore_11:
; for (l = 0; l < TETRIS_COLS; l++)
       clr.l     D2
RemoveFullRowsAndUpdateScore_15:
       cmp.l     #15,D2
       bge.s     RemoveFullRowsAndUpdateScore_17
; Table[k][l] = 0;
       move.l    D3,D0
       muls      #15,D0
       lea       0(A2,D0.L),A0
       clr.b     0(A0,D2.L)
       addq.l    #1,D2
       bra       RemoveFullRowsAndUpdateScore_15
RemoveFullRowsAndUpdateScore_17:
; compliment_to_say = mod_bld(tetris_rand(), NUM_LINE_SUCCESS_MESSAGES);
       pea       3
       move.l    D0,-(A7)
       jsr       _tetris_rand
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _mod_bld
       addq.w    #8,A7
       move.l    D0,-4(A6)
; switch (compliment_to_say)
       move.l    -4(A6),D0
       cmp.l     #1,D0
       beq.s     RemoveFullRowsAndUpdateScore_21
       bgt.s     RemoveFullRowsAndUpdateScore_24
       tst.l     D0
       beq.s     RemoveFullRowsAndUpdateScore_20
       bra.s     RemoveFullRowsAndUpdateScore_18
RemoveFullRowsAndUpdateScore_24:
       cmp.l     #2,D0
       beq.s     RemoveFullRowsAndUpdateScore_22
       bra.s     RemoveFullRowsAndUpdateScore_18
RemoveFullRowsAndUpdateScore_20:
; {
; case 0:
; say_awesome();
       jsr       _say_awesome
; break;
       bra.s     RemoveFullRowsAndUpdateScore_19
RemoveFullRowsAndUpdateScore_21:
; case 1:
; say_cool();
       jsr       _say_cool
; break;
       bra.s     RemoveFullRowsAndUpdateScore_19
RemoveFullRowsAndUpdateScore_22:
; case 2:
; say_yeah();
       jsr       _say_yeah
; break;
       bra.s     RemoveFullRowsAndUpdateScore_19
RemoveFullRowsAndUpdateScore_18:
; default:
; say_yeah();
       jsr       _say_yeah
; break;
RemoveFullRowsAndUpdateScore_19:
; }
; Tetris_Speed.speed = Tetris_Speed.speed + Tetris_Speed.speed_increase;
       move.l    (A3),D0
       add.l     4(A3),D0
       move.l    D0,(A3)
RemoveFullRowsAndUpdateScore_7:
       addq.l    #1,D4
       bra       RemoveFullRowsAndUpdateScore_1
RemoveFullRowsAndUpdateScore_3:
; }
; }
; tetris_score += 100 * count;
       move.l    D7,-(A7)
       pea       100
       jsr       LMUL
       move.l    (A7),D0
       addq.w    #8,A7
       add.l     D0,_tetris_score.L
       movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
       unlk      A6
       rts
; }
; void PrintTable()
; {
_PrintTable:
       link      A6,#-428
       movem.l   D2/D3/A2/A3/A4,-(A7)
       lea       _current.L,A2
       lea       _printw.L,A3
       lea       -300(A6),A4
; int i, j;
; char score_str[128];
; char Buffer[TETRIS_ROWS][TETRIS_COLS];
; printw_x = 0;
       clr.l     _printw_x.L
; printw_y = 0;
       clr.l     _printw_y.L
; for (i = 0; i < TETRIS_ROWS; i++)
       clr.l     D2
PrintTable_1:
       cmp.l     #20,D2
       bge.s     PrintTable_3
; {
; for (j = 0; j < TETRIS_COLS; j++)
       clr.l     D3
PrintTable_4:
       cmp.l     #15,D3
       bge.s     PrintTable_6
; {
; Buffer[i][j] = 0;
       move.l    D2,D0
       muls      #15,D0
       lea       0(A4,D0.L),A0
       clr.b     0(A0,D3.L)
       addq.l    #1,D3
       bra       PrintTable_4
PrintTable_6:
       addq.l    #1,D2
       bra       PrintTable_1
PrintTable_3:
; }
; }
; for (i = 0; i < current.width; i++)
       clr.l     D2
PrintTable_7:
       cmp.l     16(A2),D2
       bge       PrintTable_9
; {
; for (j = 0; j < current.width; j++)
       clr.l     D3
PrintTable_10:
       cmp.l     16(A2),D3
       bge       PrintTable_12
; {
; if (current.array[i][j])
       move.l    D2,D0
       lsl.l     #2,D0
       lea       0(A2,D0.L),A0
       tst.b     0(A0,D3.L)
       beq       PrintTable_13
; {
; Buffer[current.row + i][current.col + j] = current.array[i][j];
       move.l    D2,D0
       lsl.l     #2,D0
       lea       0(A2,D0.L),A0
       move.l    20(A2),D0
       add.l     D2,D0
       muls      #15,D0
       lea       0(A4,D0.L),A1
       move.l    24(A2),D0
       add.l     D3,D0
       move.b    0(A0,D3.L),0(A1,D0.L)
; TableColor[current.row + i][current.col + j] = currentColor;
       move.l    20(A2),D0
       add.l     D2,D0
       muls      #15,D0
       lea       _TableColor.L,A0
       add.l     D0,A0
       move.l    24(A2),D0
       add.l     D3,D0
       move.b    _currentColor.L,0(A0,D0.L)
PrintTable_13:
       addq.l    #1,D3
       bra       PrintTable_10
PrintTable_12:
       addq.l    #1,D2
       bra       PrintTable_7
PrintTable_9:
; }
; }
; }
; go_to_top_corner();
       jsr       _go_to_top_corner
; printw("\n\n\n", "initial_newline");
       pea       @tetris_8.L
       pea       @tetris_7.L
       jsr       (A3)
       addq.w    #8,A7
; for (i = 0; i < TETRIS_COLS - 9; i++)
       clr.l     D2
PrintTable_15:
       cmp.l     #6,D2
       bge.s     PrintTable_17
; {
; printw(" ", "space");
       pea       @tetris_10.L
       pea       @tetris_9.L
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D2
       bra       PrintTable_15
PrintTable_17:
; }
; printw("CPEN412 Tetris\n", "title");
       pea       @tetris_12.L
       pea       @tetris_11.L
       jsr       (A3)
       addq.w    #8,A7
; for (i = 0; i < TETRIS_ROWS; i++)
       clr.l     D2
PrintTable_18:
       cmp.l     #20,D2
       bge       PrintTable_20
; {
; for (j = 0; j < TETRIS_COLS; j++)
       clr.l     D3
PrintTable_21:
       cmp.l     #15,D3
       bge       PrintTable_23
; {
; if (Table[i][j] + Buffer[i][j])
       move.l    D2,D0
       muls      #15,D0
       lea       _Table.L,A0
       add.l     D0,A0
       move.b    0(A0,D3.L),D0
       move.l    D2,D1
       muls      #15,D1
       lea       0(A4,D1.L),A0
       add.b     0(A0,D3.L),D0
       beq.s     PrintTable_24
; {
; printwColor("#", TableColor[i][j], "table#");
       pea       @tetris_14.L
       move.l    D2,D1
       muls      #15,D1
       lea       _TableColor.L,A0
       add.l     D1,A0
       move.b    0(A0,D3.L),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       pea       @tetris_13.L
       jsr       _printwColor
       add.w     #12,A7
       bra.s     PrintTable_25
PrintTable_24:
; }
; else
; {
; printw(".", "table.");
       pea       @tetris_16.L
       pea       @tetris_15.L
       jsr       (A3)
       addq.w    #8,A7
PrintTable_25:
       addq.l    #1,D3
       bra       PrintTable_21
PrintTable_23:
; }
; // printw(" ","space2");
; }
; printw("\n", "newline1");
       pea       @tetris_18.L
       pea       @tetris_17.L
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D2
       bra       PrintTable_18
PrintTable_20:
; }
; sprintf(score_str, "\nScore: %d\n", tetris_score);
       move.l    _tetris_score.L,-(A7)
       pea       @tetris_19.L
       pea       -428(A6)
       jsr       _sprintf
       add.w     #12,A7
; printw(score_str, "scoreprint");
       pea       @tetris_20.L
       pea       -428(A6)
       jsr       (A3)
       addq.w    #8,A7
       movem.l   (A7)+,D2/D3/A2/A3/A4
       unlk      A6
       rts
; }
; void ManipulateCurrent(int action)
; {
_ManipulateCurrent:
       link      A6,#-28
       movem.l   A2/A3/A4,-(A7)
       lea       -28(A6),A2
       lea       _current.L,A3
       lea       _CheckPosition.L,A4
; Shape temp;
; CopyShape(&current, &temp);
       move.l    A2,-(A7)
       move.l    A3,-(A7)
       jsr       _CopyShape
       addq.w    #8,A7
; switch (action)
       move.l    8(A6),D0
       cmp.l     #115,D0
       beq.s     ManipulateCurrent_3
       bgt.s     ManipulateCurrent_7
       cmp.l     #100,D0
       beq       ManipulateCurrent_4
       bgt       ManipulateCurrent_2
       cmp.l     #97,D0
       beq       ManipulateCurrent_5
       bra       ManipulateCurrent_2
ManipulateCurrent_7:
       cmp.l     #119,D0
       beq       ManipulateCurrent_6
       bra       ManipulateCurrent_2
ManipulateCurrent_3:
; {
; case 's':
; temp.row++; // move down
       move.l    A2,D0
       add.l     #20,D0
       move.l    D0,A0
       addq.l    #1,(A0)
; if (CheckPosition(&temp))
       move.l    A2,-(A7)
       jsr       (A4)
       addq.w    #4,A7
       tst.l     D0
       beq.s     ManipulateCurrent_8
; {
; current.row++;
       move.l    A3,D0
       add.l     #20,D0
       move.l    D0,A0
       addq.l    #1,(A0)
       bra.s     ManipulateCurrent_9
ManipulateCurrent_8:
; }
; else
; {
; WriteToTable();
       jsr       _WriteToTable
; RemoveFullRowsAndUpdateScore();
       jsr       _RemoveFullRowsAndUpdateScore
; SetNewRandomShape();
       jsr       _SetNewRandomShape
ManipulateCurrent_9:
; }
; break;
       bra       ManipulateCurrent_2
ManipulateCurrent_4:
; case 'd':
; temp.col++; // move right
       move.l    A2,D0
       add.l     #24,D0
       move.l    D0,A0
       addq.l    #1,(A0)
; if (CheckPosition(&temp))
       move.l    A2,-(A7)
       jsr       (A4)
       addq.w    #4,A7
       tst.l     D0
       beq.s     ManipulateCurrent_10
; current.col++;
       move.l    A3,D0
       add.l     #24,D0
       move.l    D0,A0
       addq.l    #1,(A0)
ManipulateCurrent_10:
; break;
       bra       ManipulateCurrent_2
ManipulateCurrent_5:
; case 'a':
; temp.col--; // move left
       move.l    A2,D0
       add.l     #24,D0
       move.l    D0,A0
       subq.l    #1,(A0)
; if (CheckPosition(&temp))
       move.l    A2,-(A7)
       jsr       (A4)
       addq.w    #4,A7
       tst.l     D0
       beq.s     ManipulateCurrent_12
; current.col--;
       move.l    A3,D0
       add.l     #24,D0
       move.l    D0,A0
       subq.l    #1,(A0)
ManipulateCurrent_12:
; break;
       bra.s     ManipulateCurrent_2
ManipulateCurrent_6:
; case 'w':
; RotateShape(&temp); // rotate clockwise
       move.l    A2,-(A7)
       jsr       _RotateShape
       addq.w    #4,A7
; if (CheckPosition(&temp))
       move.l    A2,-(A7)
       jsr       (A4)
       addq.w    #4,A7
       tst.l     D0
       beq.s     ManipulateCurrent_14
; RotateShape(&current);
       move.l    A3,-(A7)
       jsr       _RotateShape
       addq.w    #4,A7
ManipulateCurrent_14:
; break;
ManipulateCurrent_2:
; }
; PrintTable();
       jsr       _PrintTable
       movem.l   (A7)+,A2/A3/A4
       unlk      A6
       rts
; }
; void initTetris_Speed()
; {
_initTetris_Speed:
; Tetris_Speed.speed = INITIAL_TETRIS_SPEED;
       move.l    #2,_Tetris_Speed.L
; Tetris_Speed.speed_increase = TETRIS_SPEED_INCREASE;
       move.l    #1,_Tetris_Speed+4.L
       rts
; }
; void tetris_mainloop()
; {
_tetris_mainloop:
       link      A6,#-4
       move.l    D2,-(A7)
; int current_time;
; int got_game_over;
; while (1)
tetris_mainloop_1:
; {
; current_time = clock();
       jsr       _clock
       move.l    D0,D2
; if (kbhit())
       jsr       _kbhit
       tst.l     D0
       beq.s     tetris_mainloop_6
; {
; ManipulateCurrent(getch());
       move.l    D0,-(A7)
       jsr       _getch
       move.l    D0,D1
       move.l    (A7)+,D0
       move.l    D1,-(A7)
       jsr       _ManipulateCurrent
       addq.w    #4,A7
; if (!GameOn)
       tst.b     _GameOn.L
       bne.s     tetris_mainloop_6
; {
; break;
       bra       tetris_mainloop_3
tetris_mainloop_6:
; }
; }
; if (current_time >= ((MILLISECONDS_PER_SEC / Tetris_Speed.speed) + tetris_timer))
       pea       1000
       move.l    _Tetris_Speed.L,-(A7)
       jsr       LDIV
       move.l    (A7),D0
       addq.w    #8,A7
       add.l     _tetris_timer.L,D0
       cmp.l     D0,D2
       blt.s     tetris_mainloop_8
; {
; ManipulateCurrent('s');
       pea       115
       jsr       _ManipulateCurrent
       addq.w    #4,A7
; if (!GameOn)
       tst.b     _GameOn.L
       bne.s     tetris_mainloop_10
; {
; break;
       bra.s     tetris_mainloop_3
tetris_mainloop_10:
; }
; tetris_timer = current_time;
       move.l    D2,_tetris_timer.L
tetris_mainloop_8:
       bra       tetris_mainloop_1
tetris_mainloop_3:
       move.l    (A7)+,D2
       unlk      A6
       rts
; }
; }
; }
; // void test(){
; // 	printf("Testing\n");
; // 	while (1){
; // 		octlAddress = 0xF3;
; // 		octlAddress1 = 0xE2;
; // 	}
; // }
; void testSound(){
_testSound:
       move.l    A2,-(A7)
       lea       _Wait250ms_here.L,A2
; say_awesome();
       jsr       _say_awesome
; Wait250ms_here();
       jsr       (A2)
; say_cool();
       jsr       _say_cool
; Wait250ms_here();
       jsr       (A2)
; say_yeah();
       jsr       _say_yeah
; Wait250ms_here();
       jsr       (A2)
; say_game_over();
       jsr       _say_game_over
; Wait250ms_here();
       jsr       (A2)
       move.l    (A7)+,A2
       rts
; }
; int tetris_main()
; {
_tetris_main:
       link      A6,#-132
       movem.l   D2/D3/A2/A3/A4,-(A7)
       lea       _ShapesArray.L,A2
       lea       _printf.L,A3
       lea       _Table.L,A4
; int i, j;
; int test1;
; char score_str[128];
; while(1){
tetris_main_1:
; testSound();
       jsr       _testSound
       bra       tetris_main_1
tetris_main_4:
       cmp.l     #15,D2
       bge       tetris_main_6
; }
; // test();
; timer_count = 0;
; printw_x = 0;
; printw_y = 0;
; GameOn = TRUE;
; InstallExceptionHandler(Timer_ISR, 30);
; Timer1Data = 0x25; // 100 ms
; Timer1Control = 3; // enable timer, periodic mode
; // InstallExceptionHandler(Timer_ISR, 29);
; // InstallExceptionHandler(Timer_ISR, 28);
; // InstallExceptionHandler(Timer_ISR, 27);
; // InstallExceptionHandler(Timer_ISR, 26);
; // InstallExceptionHandler(Timer_ISR, 25);
; octl = OCTL_TETRIS_DEFAULT;
; octlAddress = octl;
; for (j = 0; j < TETRIS_COLS; j++)
; {
; Table[0][j] = 2; // default color
       move.b    #2,0(A4,D2.L)
; for (i = 0; i < TETRIS_ROWS; i++)
       clr.l     D3
tetris_main_7:
       cmp.l     #20,D3
       bge.s     tetris_main_9
; {
; Table[i][j] = 0;
       move.l    D3,D0
       muls      #15,D0
       lea       0(A4,D0.L),A0
       clr.b     0(A0,D2.L)
; TableColor[i + 1][j] = 2; // default color
       move.l    D3,D0
       addq.l    #1,D0
       muls      #15,D0
       lea       _TableColor.L,A0
       add.l     D0,A0
       move.b    #2,0(A0,D2.L)
       addq.l    #1,D3
       bra       tetris_main_7
tetris_main_9:
       addq.l    #1,D2
       bra       tetris_main_4
tetris_main_6:
; }
; }
; // S shape
; ShapesArray[0].array[0][0] = 0;
       clr.b     (A2)
; ShapesArray[0].array[0][1] = 1;
       move.b    #1,1(A2)
; ShapesArray[0].array[0][2] = 1;
       move.b    #1,2(A2)
; ShapesArray[0].array[1][0] = 1;
       move.b    #1,4(A2)
; ShapesArray[0].array[1][1] = 1;
       move.b    #1,4+1(A2)
; ShapesArray[0].array[1][2] = 0;
       clr.b     4+2(A2)
; ShapesArray[0].array[2][0] = 0;
       clr.b     8(A2)
; ShapesArray[0].array[2][1] = 0;
       clr.b     8+1(A2)
; ShapesArray[0].array[2][2] = 0;
       clr.b     8+2(A2)
; ShapesArray[0].width = 3;
       move.l    #3,16(A2)
; // Z shape
; ShapesArray[1].array[0][0] = 1;
       move.b    #1,28(A2)
; ShapesArray[1].array[0][1] = 1;
       move.b    #1,28+1(A2)
; ShapesArray[1].array[0][2] = 0;
       clr.b     28+2(A2)
; ShapesArray[1].array[1][0] = 0;
       clr.b     28+4(A2)
; ShapesArray[1].array[1][1] = 1;
       move.b    #1,28+4+1(A2)
; ShapesArray[1].array[1][2] = 1;
       move.b    #1,28+4+2(A2)
; ShapesArray[1].array[2][0] = 0;
       clr.b     28+8(A2)
; ShapesArray[1].array[2][1] = 0;
       clr.b     28+8+1(A2)
; ShapesArray[1].array[2][2] = 0;
       clr.b     28+8+2(A2)
; ShapesArray[1].width = 3;
       move.l    #3,44(A2)
; // T shape
; ShapesArray[2].array[0][0] = 0;
       clr.b     56(A2)
; ShapesArray[2].array[0][1] = 1;
       move.b    #1,56+1(A2)
; ShapesArray[2].array[0][2] = 0;
       clr.b     56+2(A2)
; ShapesArray[2].array[1][0] = 1;
       move.b    #1,56+4(A2)
; ShapesArray[2].array[1][1] = 1;
       move.b    #1,56+4+1(A2)
; ShapesArray[2].array[1][2] = 1;
       move.b    #1,56+4+2(A2)
; ShapesArray[2].array[2][0] = 0;
       clr.b     56+8(A2)
; ShapesArray[2].array[2][1] = 0;
       clr.b     56+8+1(A2)
; ShapesArray[2].array[2][2] = 0;
       clr.b     56+8+2(A2)
; ShapesArray[2].width = 3;
       move.l    #3,72(A2)
; // L shape
; ShapesArray[3].array[0][0] = 0;
       clr.b     84(A2)
; ShapesArray[3].array[0][1] = 0;
       clr.b     84+1(A2)
; ShapesArray[3].array[0][2] = 1;
       move.b    #1,84+2(A2)
; ShapesArray[3].array[1][0] = 1;
       move.b    #1,84+4(A2)
; ShapesArray[3].array[1][1] = 1;
       move.b    #1,84+4+1(A2)
; ShapesArray[3].array[1][2] = 1;
       move.b    #1,84+4+2(A2)
; ShapesArray[3].array[2][0] = 0;
       clr.b     84+8(A2)
; ShapesArray[3].array[2][1] = 0;
       clr.b     84+8+1(A2)
; ShapesArray[3].array[2][2] = 0;
       clr.b     84+8+2(A2)
; ShapesArray[3].width = 3;
       move.l    #3,100(A2)
; // flipped L shape
; ShapesArray[4].array[0][0] = 1;
       move.b    #1,112(A2)
; ShapesArray[4].array[0][1] = 0;
       clr.b     112+1(A2)
; ShapesArray[4].array[0][2] = 0;
       clr.b     112+2(A2)
; ShapesArray[4].array[1][0] = 1;
       move.b    #1,112+4(A2)
; ShapesArray[4].array[1][1] = 1;
       move.b    #1,112+4+1(A2)
; ShapesArray[4].array[1][2] = 1;
       move.b    #1,112+4+2(A2)
; ShapesArray[4].array[2][0] = 0;
       clr.b     112+8(A2)
; ShapesArray[4].array[2][1] = 0;
       clr.b     112+8+1(A2)
; ShapesArray[4].array[2][2] = 0;
       clr.b     112+8+2(A2)
; ShapesArray[4].width = 3;
       move.l    #3,128(A2)
; // square shape
; ShapesArray[5].array[0][0] = 1;
       move.b    #1,140(A2)
; ShapesArray[5].array[0][1] = 1;
       move.b    #1,140+1(A2)
; ShapesArray[5].array[1][0] = 1;
       move.b    #1,140+4(A2)
; ShapesArray[5].array[1][1] = 1;
       move.b    #1,140+4+1(A2)
; ShapesArray[5].width = 2;
       move.l    #2,156(A2)
; // long bar shape
; ShapesArray[6].array[0][0] = 0;
       clr.b     168(A2)
; ShapesArray[6].array[0][1] = 0;
       clr.b     168+1(A2)
; ShapesArray[6].array[0][2] = 0;
       clr.b     168+2(A2)
; ShapesArray[6].array[0][3] = 0;
       clr.b     168+3(A2)
; ShapesArray[6].array[1][0] = 1;
       move.b    #1,168+4(A2)
; ShapesArray[6].array[1][1] = 1;
       move.b    #1,168+4+1(A2)
; ShapesArray[6].array[1][2] = 1;
       move.b    #1,168+4+2(A2)
; ShapesArray[6].array[1][3] = 1;
       move.b    #1,168+4+3(A2)
; ShapesArray[6].array[2][0] = 0;
       clr.b     168+8(A2)
; ShapesArray[6].array[2][1] = 0;
       clr.b     168+8+1(A2)
; ShapesArray[6].array[2][2] = 0;
       clr.b     168+8+2(A2)
; ShapesArray[6].array[2][3] = 0;
       clr.b     168+8+3(A2)
; ShapesArray[6].array[3][0] = 0;
       clr.b     168+12(A2)
; ShapesArray[6].array[3][1] = 0;
       clr.b     168+12+1(A2)
; ShapesArray[6].array[3][2] = 0;
       clr.b     168+12+2(A2)
; ShapesArray[6].array[3][3] = 0;
       clr.b     168+12+3(A2)
; ShapesArray[6].width = 4;
       move.l    #4,184(A2)
; set_color(OCTL_TETRIS_DEFAULT);
       pea       162
       jsr       _set_color
       addq.w    #4,A7
; set_vga_control_reg(OCTL_TETRIS_DEFAULT);
       pea       162
       jsr       _set_vga_control_reg
       addq.w    #4,A7
; tetris_score = 0;
       clr.l     _tetris_score.L
; initTetris_Speed();
       jsr       _initTetris_Speed
; clear_screen();
       jsr       _clear_screen
; tetris_timer = clock();
       jsr       _clock
       move.l    D0,_tetris_timer.L
; SetNewRandomShape();
       jsr       _SetNewRandomShape
; PrintTable();
       jsr       _PrintTable
; tetris_mainloop();
       jsr       _tetris_mainloop
; gameOver();
       jsr       _gameOver
; for (i = 0; i < TETRIS_ROWS; i++)
       clr.l     D3
tetris_main_10:
       cmp.l     #20,D3
       bge       tetris_main_12
; {
; for (j = 0; j < TETRIS_COLS; j++)
       clr.l     D2
tetris_main_13:
       cmp.l     #15,D2
       bge.s     tetris_main_15
; {
; if (Table[i][j])
       move.l    D3,D0
       muls      #15,D0
       lea       0(A4,D0.L),A0
       tst.b     0(A0,D2.L)
       beq.s     tetris_main_16
; {
; printf("#");
       pea       @tetris_13.L
       jsr       (A3)
       addq.w    #4,A7
       bra.s     tetris_main_17
tetris_main_16:
; }
; else
; {
; printf(".");
       pea       @tetris_15.L
       jsr       (A3)
       addq.w    #4,A7
tetris_main_17:
       addq.l    #1,D2
       bra       tetris_main_13
tetris_main_15:
; }
; }
; printf("\n");
       pea       @tetris_17.L
       jsr       (A3)
       addq.w    #4,A7
       addq.l    #1,D3
       bra       tetris_main_10
tetris_main_12:
; }
; printf("\nGame over!\n");
       pea       @tetris_21.L
       jsr       (A3)
       addq.w    #4,A7
; sprintf(score_str, "\nScore: %d\n", tetris_score);
       move.l    _tetris_score.L,-(A7)
       pea       @tetris_19.L
       pea       -128(A6)
       jsr       _sprintf
       add.w     #12,A7
; printf(score_str);
       pea       -128(A6)
       jsr       (A3)
       addq.w    #4,A7
; return 0;
       clr.l     D0
       movem.l   (A7)+,D2/D3/A2/A3/A4
       unlk      A6
       rts
; }
_strcpy:
       move.l    (4,A7),A0
       move.l    (8,A7),A1
       move.l    A0,D0
strcpy_1:
       move.b    (A1)+,(A0)+
       bne       strcpy_1
       rts
ULDIV:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       bra.s   ldiv_3
LDIV:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       tst.l   D0
       bpl.s   ldiv_1
       neg.l   D0
       tst.l   D1
       bpl.s   ldiv_2
       neg.l   D1
       bsr.s   dodiv
       neg.l   D1
       bra.s   ldiv_4
ldiv_1:
       tst.l   D1
       bpl.s   ldiv_3
       neg.l   D1
       bsr.s   dodiv
       neg.l   D0
       bra.s   ldiv_4
ldiv_2:
       bsr.s   dodiv
       neg.l   D0
       neg.l   D1
       bra.s   ldiv_4
ldiv_3:
       bsr.s   dodiv
ldiv_4:
       move.l  D0,8(A6)
       move.l  D1,12(A6)
       movem.l (A7)+,D0/D1
       unlk    A6
       rts
dodiv:
       cmpi.l  #$FFFF,D1
       bhi.s   dodiv_2
       cmpi.l  #$FFFF,D0
       bhi.s   dodiv_1
       divu    D1,D0
       move.l  D0,D1
       clr.w   D1
       swap    D1
       andi.l  #$FFFF,D0
       rts
dodiv_1:
       movem.w D0/D2,-(A7)
       clr.w   D0
       swap    D0
       divu    D1,D0
       move.w  D0,D2
       move.w  (A7)+,D0
       divu    D1,D0
       swap    D0
       clr.l   D1
       move.w  D0,D1
       move.w  D2,D0
       swap    D0
       move.w  (A7)+,D2
       rts
dodiv_2:
       movem.l D2/D3/D4,-(A7)
       move.l  D1,D2
       clr.w   D2
       swap    D2
       addq.l  #1,D2
       move.l  D0,D3
       move.l  D1,D4
       move.l  D2,D1
       bsr.s   dodiv_1
       move.l  D4,D1
       divu    D2,D1
       divu    D1,D0
       andi.l  #$FFFF,D0
dodiv_3:
       move.l  D4,D1
       move.l  D4,D2
       swap    D2
       mulu    D0,D1
       mulu    D0,D2
       swap    D2
       add.l   D2,D1
       sub.l   D3,D1
       bhi.s   dodiv_4
       neg.l   D1
       cmp.l   D1,D4
       bhi.s   dodiv_5
       addq.l  #1,D0
       bra.s   dodiv_3
dodiv_4:
       subq.l  #1,D0
       bra.s   dodiv_3
dodiv_5:
       movem.l (A7)+,D2/D3/D4
       rts
ULMUL:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       bra.s   lmul_3
LMUL:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       tst.l   D0
       bpl.s   lmul_1
       neg.l   D0
       tst.l   D1
       bpl.s   lmul_2
       neg.l   D1
       bra.s   lmul_3
lmul_1:
       tst.l   D1
       bpl.s   lmul_3
       neg.l   D1
lmul_2:
       bsr.s   domul
       neg.l   D1
       negx.l  D0
       bra.s   lmul_4
lmul_3:
       bsr.s   domul
lmul_4:
       move.l  D1,8(A6)
       movem.l (A7)+,D0/D1
       unlk    A6
       rts
domul:
       cmpi.l  #$FFFF,D1
       bhi.s   domul_1
       cmpi.l  #$FFFF,D0
       bhi.s   domul_2
       mulu    D0,D1
       rts
domul_1:
       cmpi.l  #$FFFF,D0
       bhi.s   domul_4
       bra.s   domul_3
domul_2
       exg     D0,D1
domul_3:
       move.l  D2,-(A7)
       move.l  D1,D2
       swap    D2
       mulu    D0,D1
       mulu    D0,D2
       swap    D2
       clr.w   D2
       add.l   D2,D1
       move.l  (A7)+,D2
       rts
domul_4:
       movem.l D2/D3,-(A7)
       move.l  D1,D2
       move.l  D1,D3
       mulu    D0,D1
       swap    D2
       mulu    D0,D2
       swap    D0
       mulu    D0,D3
       add.l   D3,D2
       swap    D2
       clr.w   D2
       add.l   D2,D1
       movem.l (A7)+,D2/D3
       rts
_putch:
       link      A6,#0
       movem.l   D2,-(A7)
       move.l    8(A6),D2
       cmp.l     #10,D2
       bne.s     putch_1
       pea       13
       bsr       __putch
       addq.w    #4,A7
putch_1:
       move.l    D2,-(A7)
       bsr       __putch
       addq.w    #4,A7
       move.l    D2,D0
       movem.l   (A7)+,D2
       unlk      A6
       rts
_tolower:
       link      A6,#0
       movem.l   D2,-(A7)
       move.l    8(A6),D2
       cmp.l     #65,D2
       blt.s     tolower_1
       cmp.l     #90,D2
       bgt.s     tolower_1
       or.l      #32,D2
tolower_1:
       move.l    D2,D0
       movem.l   (A7)+,D2
       unlk      A6
       rts
_sprintf:
       link      A6,#-4
       movem.l   D2,-(A7)
       lea       12(A6),A0
       addq.w    #4,A0
       move.l    A0,D2
       move.l    D2,-(A7)
       move.l    12(A6),-(A7)
       move.l    8(A6),-(A7)
       bsr       _vsprintf
       add.w     #12,A7
       move.l    D0,-4(A6)
       clr.l     D2
       move.l    -4(A6),D0
       movem.l   (A7)+,D2
       unlk      A6
       rts
_strcat:
       move.l    (4,A7),A0	
       move.l    (8,A7),A1	
       move.l    A0,D0		
strcat_0:
       tst.b     (A0)+
       bne       strcat_0
       subq      #1,A0
strcat_1:
       move.b    (A1)+,(A0)+
       bne       strcat_1
       rts
_toupper:
       link      A6,#0
       movem.l   D2,-(A7)
       move.l    8(A6),D2
       cmp.l     #97,D2
       blt.s     toupper_1
       cmp.l     #122,D2
       bgt.s     toupper_1
       and.l     #95,D2
toupper_1:
       move.l    D2,D0
       movem.l   (A7)+,D2
       unlk      A6
       rts
_printf:
       link      A6,#-4
       movem.l   D2,-(A7)
       lea       8(A6),A0
       addq.w    #4,A0
       move.l    A0,D2
       move.l    D2,-(A7)
       move.l    8(A6),-(A7)
       clr.l     -(A7)
       bsr       _vsprintf
       add.w     #12,A7
       move.l    D0,-4(A6)
       clr.l     D2
       move.l    -4(A6),D0
       movem.l   (A7)+,D2
       unlk      A6
       rts
_getch:
       movem.l   D2,-(A7)
       move.l    __ungetbuf,D2
       move.l    __ungetbuf,D0
       cmp.l     #-1,D0
       beq.s     getch_1
       move.l    #-1,__ungetbuf
       bra.s     getch_3
getch_1:
       bsr       __getch
       move.l    D0,D2
       cmp.l     #13,D0
       bne.s     getch_3
       moveq     #10,D2
getch_3:
       move.l    D2,D0
       movem.l   (A7)+,D2
       rts
@vsprintf_copy:
       link      A6,#0
       move.l    8(A6),A0
       tst.l     (A0)
       beq.s     @vsprintf_copy_1
       move.l    12(A6),D0
       move.l    8(A6),A0
       move.l    (A0),A1
       addq.l    #1,(A0)
       move.b    D0,(A1)
       bra.s     @vsprintf_copy_2
@vsprintf_copy_1:
       move.l    12(A6),-(A7)
       bsr       _putch
       addq.w    #4,A7
@vsprintf_copy_2:
       unlk      A6
       rts
@vsprintf_getval:
       link      A6,#0
       movem.l   D2/D3,-(A7)
       move.l    8(A6),D2
       clr.l     D3
       move.l    D2,A0
       move.l    (A0),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #42,D0
       bne.s     @vsprintf_getval_1
       move.l    12(A6),A0
       move.l    (A0),A1
       addq.l    #4,(A0)
       move.l    (A1),D3
       move.l    D2,A0
       addq.l    #1,(A0)
       bra       @vsprintf_getval_5
@vsprintf_getval_1:
       move.l    D2,A0
       move.l    (A0),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #48,D0
       blt       @vsprintf_getval_5
       move.l    D2,A0
       move.l    (A0),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #57,D0
       bgt.s     @vsprintf_getval_5
       move.l    D3,-(A7)
       pea       10
       bsr       LMUL
       move.l    (A7),D0
       addq.w    #8,A7
       move.l    D2,A0
       move.l    (A0),A1
       addq.l    #1,(A0)
       move.b    (A1),D1
       ext.w     D1
       ext.l     D1
       add.l     D1,D0
       sub.l     #48,D0
       move.l    D0,D3
       bra       @vsprintf_getval_1
@vsprintf_getval_5:
       move.l    D3,D0
       movem.l   (A7)+,D2/D3
       unlk      A6
       rts
_vsprintf:
       link      A6,#-52
       movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
       lea       8(A6),A2
       lea       @vsprintf_copy,A3
       lea       _ultoa,A4
       clr.l     D6
vsprintf_1:
       move.l    12(A6),A0
       tst.b     (A0)
       beq       vsprintf_3
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #37,D0
       beq.s     vsprintf_4
       move.l    12(A6),A0
       addq.l    #1,12(A6)
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       vsprintf_2
vsprintf_4:
       addq.l    #1,12(A6)
       clr.b     -45(A6)
       clr.b     -46(A6)
       clr.b     -48(A6)
       clr.b     -49(A6)
       clr.b     -50(A6)
       clr.b     -51(A6)
       clr.l     -4(A6)
       moveq     #-1,D5
       lea       -36(A6),A0
       move.l    A0,D3
       move.l    A0,D2
vsprintf_6:
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #43,D0
       beq.s     vsprintf_12
       bgt.s     vsprintf_15
       cmp.l     #35,D0
       beq       vsprintf_14
       bgt       vsprintf_9
       cmp.l     #32,D0
       beq.s     vsprintf_13
       bra.s     vsprintf_9
vsprintf_15:
       cmp.l     #45,D0
       beq.s     vsprintf_11
       bra.s     vsprintf_9
vsprintf_11:
       move.b    #1,-51(A6)
       addq.l    #1,12(A6)
       bra.s     vsprintf_7
vsprintf_12:
       move.b    #1,-50(A6)
       addq.l    #1,12(A6)
       bra.s     vsprintf_7
vsprintf_13:
       move.b    #1,-49(A6)
       addq.l    #1,12(A6)
       bra.s     vsprintf_7
vsprintf_14:
       move.b    #1,-48(A6)
       addq.l    #1,12(A6)
       bra.s     vsprintf_7
vsprintf_9:
       bra.s     vsprintf_8
vsprintf_7:
       bra       vsprintf_6
vsprintf_8:
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #48,D0
       bne.s     vsprintf_16
       addq.l    #1,12(A6)
       move.b    #1,-46(A6)
vsprintf_16:
       pea       16(A6)
       pea       12(A6)
       bsr       @vsprintf_getval
       addq.w    #8,A7
       move.l    D0,A5
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #46,D0
       bne.s     vsprintf_18
       addq.l    #1,12(A6)
       pea       16(A6)
       pea       12(A6)
       bsr       @vsprintf_getval
       addq.w    #8,A7
       move.l    D0,D5
vsprintf_18:
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #108,D0
       bne.s     vsprintf_20
       addq.l    #1,12(A6)
       move.b    #1,-45(A6)
vsprintf_20:
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #111,D0
       beq       vsprintf_27
       bgt.s     vsprintf_33
       cmp.l     #100,D0
       beq       vsprintf_24
       bgt.s     vsprintf_34
       cmp.l     #99,D0
       beq       vsprintf_30
       bgt       vsprintf_22
       cmp.l     #88,D0
       beq       vsprintf_28
       bra       vsprintf_22
vsprintf_34:
       cmp.l     #105,D0
       beq.s     vsprintf_24
       bra       vsprintf_22
vsprintf_33:
       cmp.l     #117,D0
       beq       vsprintf_26
       bgt.s     vsprintf_35
       cmp.l     #115,D0
       beq       vsprintf_31
       bra       vsprintf_22
vsprintf_35:
       cmp.l     #120,D0
       beq       vsprintf_28
       bra       vsprintf_22
vsprintf_24:
       tst.b     -45(A6)
       beq.s     vsprintf_36
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       bsr       _ltoa
       add.w     #12,A7
       bra.s     vsprintf_37
vsprintf_36:
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       bsr       _ltoa
       add.w     #12,A7
vsprintf_37:
       bra       vsprintf_23
vsprintf_26:
       tst.b     -45(A6)
       beq.s     vsprintf_38
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
       bra.s     vsprintf_39
vsprintf_38:
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
vsprintf_39:
       bra       vsprintf_23
vsprintf_27:
       tst.b     -45(A6)
       beq.s     vsprintf_40
       pea       8
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
       bra.s     vsprintf_41
vsprintf_40:
       pea       8
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
vsprintf_41:
       bra       vsprintf_23
vsprintf_28:
       tst.b     -45(A6)
       beq.s     vsprintf_42
       pea       16
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
       bra.s     vsprintf_43
vsprintf_42:
       pea       16
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
vsprintf_43:
       bra       vsprintf_23
vsprintf_30:
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),D0
       move.l    D2,A0
       addq.l    #1,D2
       move.b    D0,(A0)
       move.l    D2,A0
       clr.b     (A0)
       move.l    A5,D0
       beq.s     vsprintf_44
       move.l    A5,D0
       bra.s     vsprintf_45
vsprintf_44:
       moveq     #1,D0
vsprintf_45:
       move.l    D0,D5
       bra       vsprintf_23
vsprintf_31:
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),D3
       cmp.l     #-1,D5
       bne.s     vsprintf_46
       move.l    D3,-(A7)
       bsr       _strlen
       addq.w    #4,A7
       move.l    D0,D5
vsprintf_46:
       bra.s     vsprintf_23
vsprintf_22:
       move.l    12(A6),A0
       move.l    D2,A1
       addq.l    #1,D2
       move.b    (A0),(A1)
       move.l    D2,A0
       clr.b     (A0)
vsprintf_23:
       move.l    D3,-(A7)
       bsr       _strlen
       addq.w    #4,A7
       move.b    D0,D4
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #115,D0
       bne.s     vsprintf_48
       cmp.l     #0,D5
       blt.s     vsprintf_48
       ext.w     D4
       ext.l     D4
       cmp.l     D5,D4
       ble.s     vsprintf_50
       move.b    D5,D0
       bra.s     vsprintf_51
vsprintf_50:
       move.b    D4,D0
vsprintf_51:
       move.b    D0,D4
vsprintf_48:
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #88,D0
       bne       vsprintf_56
       lea       -36(A6),A0
       move.l    A0,D2
vsprintf_54:
       move.l    D2,A0
       tst.b     (A0)
       beq.s     vsprintf_56
       move.l    D2,A0
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       bsr       _toupper
       addq.w    #4,A7
       move.l    D2,A0
       move.b    D0,(A0)
       addq.l    #1,D2
       bra       vsprintf_54
vsprintf_56:
       moveq     #0,D7
       lea       -44(A6),A0
       move.l    A0,D2
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #100,D0
       beq.s     vsprintf_59
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #105,D0
       bne       vsprintf_65
vsprintf_59:
       tst.b     -50(A6)
       bne.s     vsprintf_62
       move.l    D3,A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #45,D0
       bne       vsprintf_60
vsprintf_62:
       move.l    D3,A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #45,D0
       bne.s     vsprintf_63
       move.l    D3,A0
       addq.l    #1,D3
       move.l    D2,A1
       addq.l    #1,D2
       move.b    (A0),(A1)
       subq.b    #1,D4
       bra.s     vsprintf_64
vsprintf_63:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #43,(A0)
vsprintf_64:
       addq.l    #1,D7
       bra       vsprintf_65
vsprintf_60:
       tst.b     -49(A6)
       beq       vsprintf_65
       move.l    D3,A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #45,D0
       bne.s     vsprintf_67
       move.l    D3,A0
       addq.l    #1,D3
       move.l    D2,A1
       addq.l    #1,D2
       move.b    (A0),(A1)
       subq.b    #1,D4
       bra.s     vsprintf_68
vsprintf_67:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #32,(A0)
vsprintf_68:
       addq.l    #1,D7
vsprintf_65:
       tst.b     -48(A6)
       beq       vsprintf_77
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #111,D0
       beq.s     vsprintf_73
       bgt.s     vsprintf_76
       cmp.l     #88,D0
       beq.s     vsprintf_73
       bra       vsprintf_77
vsprintf_76:
       cmp.l     #120,D0
       beq.s     vsprintf_73
       bra       vsprintf_77
vsprintf_73:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #48,(A0)
       addq.l    #1,D7
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #120,D0
       beq.s     vsprintf_79
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #88,D0
       bne.s     vsprintf_77
vsprintf_79:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #120,(A0)
       addq.l    #1,D7
vsprintf_77:
       move.l    D2,A0
       clr.b     (A0)
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #105,D0
       beq       vsprintf_82
       bgt.s     vsprintf_93
       cmp.l     #99,D0
       beq       vsprintf_96
       bgt.s     vsprintf_94
       cmp.l     #88,D0
       beq       vsprintf_82
       bgt       vsprintf_80
       cmp.l     #69,D0
       beq       vsprintf_82
       bra       vsprintf_80
vsprintf_94:
       cmp.l     #101,D0
       beq       vsprintf_82
       bgt       vsprintf_80
       cmp.l     #100,D0
       beq.s     vsprintf_82
       bra       vsprintf_80
vsprintf_93:
       cmp.l     #117,D0
       beq.s     vsprintf_82
       bgt.s     vsprintf_95
       cmp.l     #115,D0
       beq       vsprintf_96
       bgt       vsprintf_80
       cmp.l     #111,D0
       beq.s     vsprintf_82
       bra       vsprintf_80
vsprintf_95:
       cmp.l     #120,D0
       beq.s     vsprintf_82
       bra       vsprintf_80
vsprintf_82:
       tst.b     -46(A6)
       beq.s     vsprintf_96
       tst.b     -51(A6)
       bne.s     vsprintf_96
       move.l    A5,D0
       sub.l     D7,D0
       ext.w     D4
       ext.l     D4
       sub.l     D4,D0
       move.l    D0,-4(A6)
vsprintf_96:
       move.l    -4(A6),D0
       cmp.l     #0,D0
       bge.s     vsprintf_98
       clr.l     -4(A6)
vsprintf_98:
       tst.b     -51(A6)
       bne       vsprintf_104
       ext.w     D4
       ext.l     D4
       move.l    D4,D0
       add.l     -4(A6),D0
       add.l     D7,D0
       move.b    D0,-47(A6)
vsprintf_102:
       move.b    -47(A6),D0
       ext.w     D0
       ext.l     D0
       move.l    A5,D1
       subq.w    #1,A5
       cmp.l     D1,D0
       bge.s     vsprintf_104
       pea       32
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       vsprintf_102
vsprintf_104:
       lea       -44(A6),A0
       move.l    A0,D2
vsprintf_105:
       move.l    D2,A0
       tst.b     (A0)
       beq.s     vsprintf_107
       move.l    D2,A0
       addq.l    #1,D2
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       vsprintf_105
vsprintf_107:
       move.l    -4(A6),D0
       move.b    D0,-47(A6)
vsprintf_108:
       move.b    -47(A6),D0
       subq.b    #1,-47(A6)
       tst.b     D0
       beq.s     vsprintf_110
       pea       48
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       vsprintf_108
vsprintf_110:
       move.l    D3,A0
       tst.b     (A0)
       beq       vsprintf_113
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #115,D0
       beq.s     vsprintf_116
       bgt.s     vsprintf_119
       cmp.l     #99,D0
       beq.s     vsprintf_116
       bra.s     vsprintf_119
vsprintf_116:
       move.l    D5,D0
       subq.l    #1,D5
       cmp.l     #0,D0
       bgt.s     vsprintf_119
       bra.s     vsprintf_115
vsprintf_119:
       move.l    D3,A0
       addq.l    #1,D3
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra.s     vsprintf_112
vsprintf_115:
       bra.s     vsprintf_113
vsprintf_112:
       bra       vsprintf_110
vsprintf_113:
       tst.b     -51(A6)
       beq       vsprintf_125
       ext.w     D4
       ext.l     D4
       move.l    D4,D0
       add.l     -4(A6),D0
       add.l     D7,D0
       move.b    D0,-47(A6)
vsprintf_123:
       move.b    -47(A6),D0
       ext.w     D0
       ext.l     D0
       move.l    A5,D1
       subq.w    #1,A5
       cmp.l     D1,D0
       bge.s     vsprintf_125
       pea       32
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       subq.l    #1,D6
       bra       vsprintf_123
vsprintf_125:
       bra.s     vsprintf_81
vsprintf_80:
       move.l    12(A6),A0
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
vsprintf_81:
       addq.l    #1,12(A6)
vsprintf_2:
       bra       vsprintf_1
vsprintf_3:
       tst.l     (A2)
       beq.s     vsprintf_126
       clr.b     D1
       and.l     #255,D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
vsprintf_126:
       move.l    D6,D0
       movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
       unlk      A6
       rts
@itoa_convert:
       link      A6,#0
       movem.l   D2/D3/D4/D5,-(A7)
       move.l    8(A6),D2
       move.l    16(A6),D3
       move.l    12(A6),D5
       move.l    D5,-(A7)
       move.l    D3,-(A7)
       bsr       ULDIV
       move.l    4(A7),D0
       addq.w    #8,A7
       move.l    D0,D4
       cmp.l     D3,D5
       blo.s     @itoa_convert_1
       move.l    D3,-(A7)
       move.l    D5,-(A7)
       move.l    D3,-(A7)
       bsr       ULDIV
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    D1,-(A7)
       move.l    D2,-(A7)
       bsr       @itoa_convert
       add.w     #12,A7
       move.l    D0,D2
@itoa_convert_1:
       cmp.l     #9,D4
       bgt.s     @itoa_convert_3
       move.l    D4,D0
       add.l     #48,D0
       bra.s     @itoa_convert_4
@itoa_convert_3:
       move.l    D4,D0
       add.l     #97,D0
       sub.l     #10,D0
@itoa_convert_4:
       move.l    D2,A0
       move.b    D0,(A0)
       move.l    D2,D0
       addq.l    #1,D0
       movem.l   (A7)+,D2/D3/D4/D5
       unlk      A6
       rts
_ltoa:
       link      A6,#0
       movem.l   D2/D3/D4/D5,-(A7)
       move.l    8(A6),D2
       move.l    12(A6),D3
       move.l    16(A6),D5
       move.l    D3,D4
       cmp.l     #2,D5
       blt.s     ltoa_3
       cmp.l     #36,D5
       ble.s     ltoa_1
ltoa_3:
       move.l    D3,D0
       bra       ltoa_4
ltoa_1:
       cmp.l     #10,D5
       bne       ltoa_5
       cmp.l     #0,D2
       bge.s     ltoa_5
       move.l    D2,D0
       neg.l     D0
       move.l    D0,D2
       cmp.l     #0,D2
       bge.s     ltoa_7
       pea       @itoa_1
       move.l    D3,-(A7)
       bsr       _strcpy
       addq.w    #8,A7
       move.l    D3,D0
       bra.s     ltoa_4
ltoa_7:
       move.l    D4,A0
       addq.l    #1,D4
       move.b    #45,(A0)
ltoa_5:
       move.l    D5,-(A7)
       move.l    D2,-(A7)
       move.l    D4,-(A7)
       bsr       @itoa_convert
       add.w     #12,A7
       move.l    D0,D4
       move.l    D4,A0
       clr.b     (A0)
       move.l    D3,D0
ltoa_4:
       movem.l   (A7)+,D2/D3/D4/D5
       unlk      A6
       rts
_ultoa:
       link      A6,#0
       movem.l   D2/D3/D4,-(A7)
       move.l    16(A6),D3
       move.l    12(A6),D4
       move.l    D4,D2
       cmp.l     #2,D3
       blt.s     ultoa_3
       cmp.l     #36,D3
       ble.s     ultoa_1
ultoa_3:
       move.l    D4,D0
       bra.s     ultoa_4
ultoa_1:
       move.l    D3,-(A7)
       move.l    8(A6),-(A7)
       move.l    D2,-(A7)
       bsr       @itoa_convert
       add.w     #12,A7
       move.l    D0,D2
       move.l    D2,A0
       clr.b     (A0)
       move.l    D4,D0
ultoa_4:
       movem.l   (A7)+,D2/D3/D4
       unlk      A6
       rts
_itoa:
       link      A6,#0
       move.l    16(A6),-(A7)
       move.l    12(A6),-(A7)
       move.l    8(A6),-(A7)
       bsr       _ltoa
       add.w     #12,A7
       unlk      A6
       rts
_strlen:
       move.l    (4,A7),A0
       move.l    A0,A1
strlen_1:
       tst.b     (A1)+
       bne       strlen_1
       move.l    A1,D0
       sub.l     A0,D0
       subq.l    #1,D0
       rts
       section   const

@m68kde~1_1:
       dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
       dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
       dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
       dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
       dc.b      110,117,101,0
@m68kde~1_2:
       dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
       dc.b      32,65,100,100,114,101,115,115,58,32,0
@m68kde~1_3:
       dc.b      13,10,37,48,56,120,32,0
@m68kde~1_4:
       dc.b      37,48,50,88,0
@m68kde~1_5:
       dc.b      32,32,0
@m68kde~1_6:
       dc.b      13,10,0
@m68kde~1_7:
       dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
       dc.b      32,66,108,111,99,107,0
@m68kde~1_8:
       dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
       dc.b      100,100,114,101,115,115,58,32,0
@m68kde~1_9:
       dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
       dc.b      68,97,116,97,58,32,0
@m68kde~1_10:
       dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
       dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
       dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
       dc.b      32,36,37,48,50,88,0
@m68kde~1_11:
       dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
       dc.b      114,109,105,110,97,108,32,116,111,32,83,101
       dc.b      110,100,32,84,101,120,116,32,70,105,108,101
       dc.b      32,40,46,104,101,120,41,13,10,0
@m68kde~1_12:
       dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
       dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
       dc.b      32,91,36,37,48,56,88,93,13,10,0
@m68kde~1_13:
       dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
       dc.b      119,110,108,111,97,100,101,100,32,37,100,32
       dc.b      98,121,116,101,115,13,10,0
@m68kde~1_14:
       dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
       dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
       dc.b      121,0
@m68kde~1_15:
       dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
       dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
       dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
       dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
       dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
       dc.b      0
@m68kde~1_16:
       dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
       dc.b      115,115,58,32,0
@m68kde~1_17:
       dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
       dc.b      32,32,0
@m68kde~1_18:
       dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
       dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
       dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
       dc.b      82,101,97,100,32,91,37,48,50,120,93,0
@m68kde~1_19:
       dc.b      36,37,48,56,88,32,32,0
@m68kde~1_20:
       dc.b      32,0
@m68kde~1_21:
       dc.b      46,0
@m68kde~1_22:
       dc.b      37,99,0
@m68kde~1_23:
       dc.b      0
@m68kde~1_24:
       dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
       dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
@m68kde~1_25:
       dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
       dc.b      65,49,32,61,32,36,37,48,56,88,0
@m68kde~1_26:
       dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
       dc.b      65,50,32,61,32,36,37,48,56,88,0
@m68kde~1_27:
       dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
       dc.b      65,51,32,61,32,36,37,48,56,88,0
@m68kde~1_28:
       dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
       dc.b      65,52,32,61,32,36,37,48,56,88,0
@m68kde~1_29:
       dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
       dc.b      65,53,32,61,32,36,37,48,56,88,0
@m68kde~1_30:
       dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
       dc.b      65,54,32,61,32,36,37,48,56,88,0
@m68kde~1_31:
       dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
       dc.b      65,55,32,61,32,36,37,48,56,88,0
@m68kde~1_32:
       dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
       dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
       dc.b      0
@m68kde~1_33:
       dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
       dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
       dc.b      111,114,32,83,80,0
@m68kde~1_34:
       dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
       dc.b      32,0
@m68kde~1_35:
       dc.b      32,32,32,91,0
@m68kde~1_36:
       dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
       dc.b      0
@m68kde~1_37:
       dc.b      91,64,32,66,82,69,65,75,80,79,73,78,84,93,0
@m68kde~1_38:
       dc.b      13,10,87,80,37,100,32,61,32,37,115,0
@m68kde~1_39:
       dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
       dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
       dc.b      78,93,0
@m68kde~1_40:
       dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
       dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
       dc.b      0
@m68kde~1_41:
       dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
       dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
       dc.b      78,101,120,116,32,73,110,115,116,114,117,99
       dc.b      116,105,111,110,0
@m68kde~1_42:
       dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
       dc.b      116,111,32,82,101,115,117,109,101,32,80,114
       dc.b      111,103,114,97,109,0
@m68kde~1_43:
       dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
       dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
       dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
       dc.b      13,10,0
@m68kde~1_44:
       dc.b      13,10,68,37,99,32,61,32,0
@m68kde~1_45:
       dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
       dc.b      114,101,115,115,32,82,101,103,105,115,116,101
       dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
       dc.b      46,46,46,46,13,10,0
@m68kde~1_46:
       dc.b      13,10,65,37,99,32,61,32,0
@m68kde~1_47:
       dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
@m68kde~1_48:
       dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
       dc.b      105,115,116,101,114,46,46,46,46,0
@m68kde~1_49:
       dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
       dc.b      32,0
@m68kde~1_50:
       dc.b      13,10,80,67,32,61,32,0
@m68kde~1_51:
       dc.b      13,10,83,82,32,61,32,0
@m68kde~1_52:
       dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
       dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
       dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
       dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
       dc.b      82,13,10,0
@m68kde~1_53:
       dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
       dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
       dc.b      115,116,114,117,99,116,105,111,110,0
@m68kde~1_54:
       dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
       dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
       dc.b      45,45,45,45,0
@m68kde~1_55:
       dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
       dc.b      110,116,115,32,83,101,116,0
@m68kde~1_56:
       dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
       dc.b      0
@m68kde~1_57:
       dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
       dc.b      101,115,115,0
@m68kde~1_58:
       dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
       dc.b      45,45,45,45,0
@m68kde~1_59:
       dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
       dc.b      110,116,115,32,83,101,116,0
@m68kde~1_60:
       dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
       dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
       dc.b      58,32,0
@m68kde~1_61:
       dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
       dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
       dc.b      0
@m68kde~1_62:
       dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
       dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
       dc.b      13,10,0
@m68kde~1_63:
       dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
       dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
       dc.b      46,46,46,0
@m68kde~1_64:
       dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
       dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
       dc.b      58,32,0
@m68kde~1_65:
       dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
       dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
       dc.b      13,10,0
@m68kde~1_66:
       dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
       dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
       dc.b      46,46,46,46,0
@m68kde~1_67:
       dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
       dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
       dc.b      0
@m68kde~1_68:
       dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
       dc.b      32,65,100,100,114,101,115,115,58,32,0
@m68kde~1_69:
       dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
       dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
       dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
       dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
       dc.b      115,0
@m68kde~1_70:
       dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
       dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
       dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
       dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
       dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
       dc.b      70,70,93,0
@m68kde~1_71:
       dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
       dc.b      107,32,80,111,105,110,116,32,65,108,114,101
       dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
       dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
       dc.b      56,120,13,10,0
@m68kde~1_72:
       dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
       dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
       dc.b      115,115,58,32,91,36,37,48,56,120,93,0
@m68kde~1_73:
       dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
       dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
       dc.b      0
@m68kde~1_74:
       dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
       dc.b      32,65,100,100,114,101,115,115,58,32,0
@m68kde~1_75:
       dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
       dc.b      104,32,80,111,105,110,116,32,65,108,114,101
       dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
       dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
       dc.b      10,0
@m68kde~1_76:
       dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
       dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
       dc.b      115,115,58,32,91,36,37,48,56,120,93,0
@m68kde~1_77:
       dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
       dc.b      79,73,78,84,0
@m68kde~1_78:
       dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
       dc.b      32,58,32,91,79,78,93,0
@m68kde~1_79:
       dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
       dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
@m68kde~1_80:
       dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
       dc.b      116,111,32,82,101,115,117,109,101,32,85,115
       dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
@m68kde~1_81:
       dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
       dc.b      109,97,110,100,46,46,46,46,46,13,10,0
@m68kde~1_82:
       dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
       dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
       dc.b      46,46,46,0
@m68kde~1_83:
       dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
       dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
       dc.b      40,121,47,110,41,63,0
@m68kde~1_84:
       dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
       dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
       dc.b      40,121,47,110,41,63,0
@m68kde~1_85:
       dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
       dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
       dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
       dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
       dc.b      45,45,45,45,45,45,0
@m68kde~1_86:
       dc.b      13,10,32,32,70,105,110,97,108,32,80,114,111
       dc.b      106,101,99,116,0
@m68kde~1_87:
       dc.b      13,10,32,32,72,32,32,32,32,45,32,83,97,121,32
       dc.b      72,101,108,108,111,32,87,111,114,108,100,0
@m68kde~1_88:
       dc.b      13,10,32,32,84,32,32,32,32,45,32,82,117,110
       dc.b      32,84,101,116,114,105,115,32,71,97,109,101,0
@m68kde~1_89:
       dc.b      13,10,35,0
@m68kde~1_90:
       dc.b      10,82,117,110,110,105,110,103,32,84,101,116
       dc.b      114,105,115,32,71,97,109,101,10,0
@m68kde~1_91:
       dc.b      10,83,97,121,105,110,103,32,72,101,108,108,111
       dc.b      32,87,111,114,108,100,10,0
@m68kde~1_92:
       dc.b      10,77,101,109,111,114,121,32,67,104,97,110,103
       dc.b      101,32,105,110,32,86,71,65,10,0
@m68kde~1_93:
       dc.b      10,65,100,100,114,101,115,115,58,32,48,120,37
       dc.b      48,52,88,44,32,68,97,116,97,58,32,37,99,0
@m68kde~1_94:
       dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
       dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
@m68kde~1_95:
       dc.b      37,115,13,10,0
@m68kde~1_96:
       dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
       dc.b      66,79,82,84,32,33,33,33,33,33,0
@m68kde~1_97:
       dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
       dc.b      110,116,101,114,114,117,112,116,58,32,73,82
       dc.b      81,37,100,32,33,33,33,33,33,0
@m68kde~1_98:
       dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
       dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
       dc.b      114,97,110,115,102,101,114,32,116,111,47,102
       dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
       dc.b      100,114,101,115,115,46,46,46,46,0
@m68kde~1_99:
       dc.b      85,110,104,97,110,100,108,101,100,32,84,114
       dc.b      97,112,32,33,33,33,33,33,0
@m68kde~1_100:
       dc.b      66,85,83,32,69,114,114,111,114,33,0
@m68kde~1_101:
       dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
       dc.b      0
@m68kde~1_102:
       dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
       dc.b      84,73,79,78,0
@m68kde~1_103:
       dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
@m68kde~1_104:
       dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
       dc.b      79,78,0
@m68kde~1_105:
       dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
       dc.b      79,78,0
@m68kde~1_106:
       dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
       dc.b      84,73,79,78,0
@m68kde~1_107:
       dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
       dc.b      82,81,0
@m68kde~1_108:
       dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
@m68kde~1_109:
       dc.b      67,80,69,78,32,52,49,50,32,50,48,50,51,87,50
       dc.b      13,10,84,111,109,32,87,97,110,103,44,32,55,54
       dc.b      51,52,48,51,52,56,0
@m68kde~1_110:
       dc.b      67,111,112,121,114,105,103,104,116,32,40,67
       dc.b      41,32,80,74,32,68,97,118,105,101,115,32,50,48
       dc.b      49,54,0
@m68kde~1_111:
       dc.b      13,10,37,115,0
@tetris_1:
       dc.b      37,115,10,0
@tetris_2:
       dc.b      103,97,109,101,32,111,118,101,114,0
@tetris_3:
       dc.b      32,71,97,109,101,32,111,118,101,114,33,32,0
@tetris_4:
       dc.b      32,83,99,111,114,101,58,32,37,100,32,0
@tetris_5:
       dc.b      80,114,101,115,115,32,97,110,121,32,107,101
       dc.b      121,32,116,111,32,99,111,110,116,105,110,117
       dc.b      101,10,0
@tetris_6:
       dc.b      115,99,111,114,101,0
@tetris_7:
       dc.b      10,10,10,0
@tetris_8:
       dc.b      105,110,105,116,105,97,108,95,110,101,119,108
       dc.b      105,110,101,0
@tetris_9:
       dc.b      32,0
@tetris_10:
       dc.b      115,112,97,99,101,0
@tetris_11:
       dc.b      67,80,69,78,52,49,50,32,84,101,116,114,105,115
       dc.b      10,0
@tetris_12:
       dc.b      116,105,116,108,101,0
@tetris_13:
       dc.b      35,0
@tetris_14:
       dc.b      116,97,98,108,101,35,0
@tetris_15:
       dc.b      46,0
@tetris_16:
       dc.b      116,97,98,108,101,46,0
@tetris_17:
       dc.b      10,0
@tetris_18:
       dc.b      110,101,119,108,105,110,101,49,0
@tetris_19:
       dc.b      10,83,99,111,114,101,58,32,37,100,10,0
@tetris_20:
       dc.b      115,99,111,114,101,112,114,105,110,116,0
@tetris_21:
       dc.b      10,71,97,109,101,32,111,118,101,114,33,10,0
       section   data
                align
DataStart       equ       *

*********************************************************************************************************
* Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
* to ram as part of the CStart routine in this file
*********************************************************************************************************

@itoa_1:
       dc.b      45,50,49,52,55,52,56,51,54,52,56,0
       section   bss
                align
DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it

*********************************************************************************************************
* Section for Uninitialised Data held in ROM as constants
*********************************************************************************************************

                org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup


bss             org       bss

*********************************************************************************************************
* Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
* install the exception handler using the C function InstallExceptionHandler()
*********************************************************************************************************



VInitialSP       ds.l    1      dummy as we can't really install a handler for this
VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
VBusError        ds.l    1      storage for address of Bus Error Handler
VAddressError    ds.l    1      storage for address of Address Error Handler
VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
VDividebyZero    ds.l    1      storage for address of divide by zero handler
VCheck           ds.l    1      ditto
VTrapV           ds.l    1      ditto
VPrivilege       ds.l    1      ditto
VTrace           ds.l    1
VLine1010emul    ds.l    1
VLine1111emul    ds.l    1
VUnassigned1     ds.l    1
VUnassigned2     ds.l    1
VUnassigned3     ds.l    1
VUninit_IRQ      ds.l    1
VUnassigned4     ds.l    1
VUnassigned5     ds.l    1
VUnassigned6     ds.l    1
VUnassigned7     ds.l    1
VUnassigned8     ds.l    1
VUnassigned9     ds.l    1
VUnassigned10    ds.l    1
VUnassigned11    ds.l    1
VSpuriousIRQ     ds.l    1

* Interrupt handlers Vector 25-31
VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()

* Trap Handler vectors 32-47
VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()

* the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here

***********************************************************************************************************
* Other Variables
***********************************************************************************************************
*__DebugA5       ds.l    1
*__UserA5        ds.l    1

***********************************************************************************************************
__ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
__allocp:       ds.l    0       ; start of allocation units
__heap:         ds.l    0       ; pointers for malloc functions

*__himem:       ds.l    himem            ; highest memory location + 1
*__stklen:      ds.l    stklen           ; default stack size

*********************************************************************************************************
* Section for Heap
*********************************************************************************************************

_i:
       ds.b      4
_x:
       ds.b      4
_y:
       ds.b      4
_z:
       ds.b      4
_PortA_Count:
       ds.b      4
_Trace:
       ds.b      4
_GoFlag:
       ds.b      4
_Echo:
       ds.b      4
_d0:
       ds.b      4
_d1:
       ds.b      4
_d2:
       ds.b      4
_d3:
       ds.b      4
_d4:
       ds.b      4
_d5:
       ds.b      4
_d6:
       ds.b      4
_d7:
       ds.b      4
_a0:
       ds.b      4
_a1:
       ds.b      4
_a2:
       ds.b      4
_a3:
       ds.b      4
_a4:
       ds.b      4
_a5:
       ds.b      4
_a6:
       ds.b      4
_PC:
       ds.b      4
_SSP:
       ds.b      4
_USP:
       ds.b      4
_SR:
       ds.b      2
_BreakPointAddress:
       ds.b      32
_BreakPointInstruction:
       ds.b      16
_BreakPointSetOrCleared:
       ds.b      32
_InstructionSize:
       ds.b      4
_WatchPointAddress:
       ds.b      32
_WatchPointSetOrCleared:
       ds.b      32
_WatchPointString:
       ds.b      800
_TempString:
       ds.b      100
_Table:
       ds.b      300
_TableColor:
       ds.b      315
_currentColor:
       ds.b      1
_tetris_score:
       ds.b      4
_GameOn:
       ds.b      1
_tetris_timer:
       ds.b      4
_octl:
       ds.b      1
_current:
       ds.b      28
_ShapesArray:
       ds.b      196
_Tetris_Speed:
       ds.b      8
_printw_x:
       ds.b      4
_printw_y:
       ds.b      4
_cx:
       ds.b      1
_cy:
       ds.b      1
_timer_count:
       ds.b      4
       section   heap
                align
bssEnd          equ *                   end of storage space for unitialised variables
*                                       we have to copy all initialised variable from rom to here at startup
heap   equ       *
                 align
